{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Elasticmagic","text":"<p>Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries.</p> <p>Warning</p> <p>The library is in very alpha status. API may change significantly at any time. Use it on your own risk</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#setup","title":"Setup","text":"<p>Add following dependencies in your <code>build.gradle.kts</code> script:</p> <pre><code>repositories {\n    mavenCentral()\n}\n\nval elasticmagicVersion = \"0.3.0-2-g6d95f3f\"\nval ktorVersion = \"3.0.3\"\n\ndependencies {\n    // Elasticmagic core api\n    implementation(\"dev.evo.elasticmagic:elasticmagic:$elasticmagicVersion\")\n    // Json serialization using kotlinx.serialization\n    implementation(\"dev.evo.elasticmagic:elasticmagic-serde-kotlinx-json:$elasticmagicVersion\")\n    // Transport that uses ktor http client\n    implementation(\"dev.evo.elasticmagic:elasticmagic-transport-ktor:$elasticmagicVersion\")\n\n    implementation(\"io.ktor:ktor-client-cio:$ktorVersion\")\n}\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>First you need to describe a document (represents a mapping in terms of Elasticsearch):</p> <p>Now create <code>ElasticsearchCluster</code> object. It is an entry point for executing search queries:</p> <pre><code>\n</code></pre> <p>Any <code>ElasticsearchCluster</code> needs an <code>ElasticsearchTransport</code>. We will use the <code>ElasticsearchKtorTransport</code> that utilises Ktor http client.</p> <p>Here are examples of creating transports for the cluster.</p> <p>JVM:</p> <pre><code>\n</code></pre> <p>Native:</p> <pre><code>\n</code></pre> <p>Create our index if it does not exist or update the mapping otherwise:</p> <pre><code>\n</code></pre> <p>Describe document sources and index them: </p> <pre><code>\n</code></pre> <p>And finally we can search our data:</p> <pre><code>\n</code></pre>"},{"location":"#run-the-sample","title":"Run the sample","text":"<p>You can find fully working example inside samples</p> <p>And run it with as JVM application (of cause you need Elasticsearch available at <code>localhost:9200</code>):</p> <pre><code>./gradlew :samples:run\n</code></pre> <p>or native:</p> <pre><code>./gradlew :samples:runDebugExecutableNative\n</code></pre>"},{"location":"docsource/","title":"Document source","text":"<p>Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with <code>String</code> or <code>List&lt;String&gt;</code>. Also all fields in a mapping are optional that requires <code>null</code>-checks in the code. Specifying document source we can set up proper (de)serialization of underlying data.</p> <p>Warning</p> <p>This API is a subject to change.  See more info at issue</p> <p>Suppose we have following <code>Document</code>:</p> <pre><code>\n</code></pre>"},{"location":"docsource/#dynamic","title":"Dynamic","text":"<p>The most simple way to work with source documents is just to use <code>DynDocSource</code>:</p> <pre><code>\n</code></pre>"},{"location":"docsource/#user-defined","title":"User defined","text":"<p>This is the recommended way. You can explicitly specify document source:</p>"},{"location":"document/","title":"Document (aka mapping)","text":"<p>Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into  a single mapping.</p> <p>It is convenient to describe <code>Document</code> subclasses as singleton objects.</p> <p>Read more about  Elasticsearch mapping types</p>"},{"location":"document/#simple-fields","title":"Simple fields","text":""},{"location":"document/#general-way","title":"General way","text":"<p>You can use field method to describe a field in a document:</p> <p>Fields can be used when building a search query:</p>"},{"location":"document/#using-shortcuts","title":"Using shortcuts","text":"<p>There are some nice shortcuts for popular field types.  You don't need to import all those field types:</p> <p>Full list of available shortcuts can be found here</p>"},{"location":"document/#enums","title":"Enums","text":"<p>It is possible to map field values to kotlin enums. Use enum extension function for that:</p> <p>Now you are able to use enum variants in your search queries:</p>"},{"location":"document/#sub-fields","title":"Sub fields","text":"<p>It is possible to define sub-fields for any simple field:</p> <p>Sub-fields also can be used in search queries:</p> <p>Note</p> <p>It is a mistake to use sub-fields twice. Following example will fail at runtime.</p> Show an error <pre><code>Exception in thread \"main\" java.lang.ExceptionInInitializerError\n        at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17)\n        at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt)\nCaused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about]\n        at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363)\n        at samples.document.subfields.mistake.UserDoc.&lt;clinit&gt;(Mistake.kt:13)\n        ... 2 more\n</code></pre>"},{"location":"document/#object-fields","title":"Object fields","text":""},{"location":"document/#object","title":"Object","text":"<p>Object type just represents a hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value:</p> <p>Note</p> <p>The same as with the sub-fields sub-document should not be a singleton object. </p> <p>Read more:</p> <ul> <li>Elasticsearch object type</li> <li>Object API</li> </ul>"},{"location":"document/#nested","title":"Nested","text":"<p>Using nested type it you can work with sub-documents independently.  In the example below we find all users that have a <code>moderator</code> role with both  <code>article</code> and <code>order</code> permissions:</p> <pre><code>\n</code></pre> <p>If we tried to make it with <code>object</code> type, we would find users that have  a <code>moderator</code> role with <code>article</code> permission and <code>view</code> role with <code>order</code> permission.</p> <p>Read more:</p> <ul> <li>Elasticsearch nested type</li> <li>Nested API</li> </ul>"},{"location":"document/#parent-child-relationship","title":"Parent-child relationship","text":"<p>Parent/child relationship allows you to define a link between documents inside an index.</p>"},{"location":"document/#join-field","title":"Join field","text":"<p>Read more:</p> <ul> <li>Elasticsearch join type</li> <li>Join API</li> </ul>"},{"location":"document/#meta-fields","title":"Meta fields","text":"<p>Elasticsearch mapping has metadata fields. Some of those fields can be customized. In following example we make a value for <code>_routing</code> field required and keep only <code>name</code> field in document source:</p> <pre><code>\n</code></pre> <p>Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw <code>routing_missing_exceptions</code>.</p>"},{"location":"document/#merge-multiple-documents","title":"Merge multiple documents","text":"<p>To create a mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other.</p> <p>Resulting document can be used when creating an index or updating an existing mapping. </p>"},{"location":"query-filters/","title":"Query Filters","text":"<p>Query filters allow you to describe search query modifications declaratively. It is possible to filter, sort, paginate and build facets using query filters.</p> <p>Let's describe our new document:</p> <p>Now we can describe query filters for the <code>BikeDoc</code>:</p> <pre><code>\n</code></pre> <p>To apply it to a search query you need query filter parameters. They are just a mapping where keys are a pair of filter name and an operation, and values are a list of strings. For example, it could be transformed from http query parameters.</p> <pre><code>\n</code></pre> <p>After executing query we are able to process its results:</p> <pre><code>\n</code></pre>"},{"location":"query-filters/#run-a-full-fledged-query-filters-sample","title":"Run a full-fledged query filters sample","text":"<p>JVM version:</p> <pre><code>./gradlew :samples:runBikeshop -q --console=plain\n</code></pre> <p>Native version:</p> <pre><code>./gradlew :samples:linkBikeshopDebugExecutableNative\n./samples/build/bin/native/bikeshopDebugExecutable/bikeshop.kexe\n</code></pre> <p>Both versions support following environment variables:</p> <ul> <li><code>ELASTIC_URL</code> - URL to your Elasticsearch cluster. Default is <code>http://localhost:9200</code>.   If you want to use TLS change it to <code>https://localhost:9200</code>. Elasticsearch <code>8.x</code> and   Opensearch <code>2.x</code> turn on TLS by default.</li> <li><code>ELASTIC_USER</code> - user for a basic authentication. Default is <code>elastic</code>.   Change it to <code>admin</code> if you use Opensearch.</li> <li><code>ELASTIC_PASSWORD</code> - if this variable is set, basic authentication will be used.   Set it to a real password of your cluster or leave empty if your cluster doesn't require   authentication. Password for default configuration of Elasticsearch <code>8.x</code> can be found in logs.   Default password for Opensearch <code>2.x</code> is <code>admin</code>.</li> </ul>"},{"location":"querying/","title":"Querying","text":"<p>To build a search query use a SearchQuery builder.</p> <p>In these samples we will utilize following document:</p>"},{"location":"querying/#query","title":"Query","text":"<p>You can pass a query to <code>SearchQuery</code> directly via its constructor:</p> <pre><code>\n</code></pre> <p>Also it is possible to replace existing query using a <code>query</code> method: </p> <pre><code>\n</code></pre> <p>See full list of available query expressions.</p>"},{"location":"querying/#cloning","title":"Cloning","text":"<p>In the last example <code>q</code> and <code>q2</code> variables point to the same object. For efficiency all <code>SearchQuery</code> methods modify current instance and return it for chaining method calls.</p> <p>If you want to get independent query instance you should clone it explicitly:</p> <pre><code>\n</code></pre> <p>Now you can modify <code>clonedQuery</code> without touching its ancestor <code>q</code>.</p>"},{"location":"querying/#filtering","title":"Filtering","text":"<p>Using filter method you can filter your query. All filters passed to the <code>filter</code> method will be combined using <code>AND</code> operation.</p> <pre><code>\n</code></pre> <p>See Query Filter Context</p>"},{"location":"querying/#sorting","title":"Sorting","text":"<p>sort method has 2 flavors:</p> <ul> <li>a shortcut that accepts document fields</li> <li>and full-featured version accepting Sort   expressions</li> </ul> <p>See:</p> <ul> <li>Sort Search Results</li> </ul>"},{"location":"querying/#aggregations","title":"Aggregations","text":"<p>Use aggs method to define aggregations:</p> <p>See Search Aggregations</p>"},{"location":"querying/#query-nodes","title":"Query Nodes","text":"<p>Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to replace parts of the query after creation using special query expressions and queryNode method:</p>"}]}