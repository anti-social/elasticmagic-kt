{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Elasticmagic \u00b6 Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk Getting started \u00b6 Setup \u00b6 Add following dependencies in your build.gradle.kts script: repositories { mavenCentral () } val elasticmagicVersion = \"0.0.19-35-g1e1feb6\" val ktorVersion = \"2.2.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-kotlinx-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) } Usage \u00b6 First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.kotlinx.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport const val DEFAULT_ELASTIC_URL = \"http://localhost:9200\" const val DEFAULT_ELASTIC_USER = \"elastic\" expect val esTransport : ElasticsearchKtorTransport val cluster = ElasticsearchCluster ( esTransport , serde = JsonSerde ) val userIndex = cluster [ \"elasticmagic-samples_user\" ] Any ElasticsearchCluster needs an ElasticsearchTransport . We will use the ElasticsearchKtorTransport that utilises Ktor http client. Here are examples of creating transports for the cluster. JVM: package samples.started import dev.evo.elasticmagic.transport.Auth import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import dev.evo.elasticmagic.transport.Request import dev.evo.elasticmagic.transport.Response import dev.evo.elasticmagic.transport.PlainRequest import dev.evo.elasticmagic.transport.PlainResponse import dev.evo.elasticmagic.transport.Tracker import io.ktor.client.engine.cio.CIO import java.security.cert.X509Certificate import javax.net.ssl.X509TrustManager import kotlin.time.Duration import kotlin.getOrThrow actual val esTransport = ElasticsearchKtorTransport ( System . getenv ( \"ELASTIC_URL\" ) ?: DEFAULT_ELASTIC_URL , engine = CIO . create { https { trustManager = object : X509TrustManager { override fun checkClientTrusted ( chain : Array < out X509Certificate >? , authType : String? ) {} override fun checkServerTrusted ( chain : Array < out X509Certificate >? , authType : String? ) {} override fun getAcceptedIssuers (): Array < X509Certificate >? = null } } } ) { val elasticUser = System . getenv ( \"ELASTIC_USER\" ) ?: DEFAULT_ELASTIC_USER val elasticPassword = System . getenv ( \"ELASTIC_PASSWORD\" ) if ( ! elasticPassword . isNullOrEmpty ()) { auth = Auth . Basic ( elasticUser , elasticPassword ) } if ( System . getenv ( \"ELASTICMAGIC_DEBUG\" ) != null ) { trackers = listOf { object : Tracker { override fun requiresTextContent ( request : Request <* , * , *> ) = true override fun onRequest ( request : PlainRequest ) { println ( \">>>\" ) println ( \" ${ request . method } ${ request . path . ifEmpty { \"/\" } } \" ) println ( request . textContent ) } override fun onResponse ( responseResult : Result < PlainResponse > , duration : Duration ) { responseResult . onSuccess { response -> println ( \"<<< ${ response . statusCode } : ${ duration } \" ) response . headers . forEach { header -> println ( \"< ${ header . key } : ${ header . value } \" ) } println ( response . contentType ) println ( response . content ) } . onFailure { exception -> println ( \"!!! $ exception \" ) } } } } } } Native: package samples.started import dev.evo.elasticmagic.serde.kotlinx.JsonSerde import dev.evo.elasticmagic.transport.Auth import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.curl.Curl import kotlinx.cinterop.toKString import platform.posix.getenv actual val esTransport = ElasticsearchKtorTransport ( getenv ( \"ELASTIC_URL\" ) ?. toKString () ?: DEFAULT_ELASTIC_URL , engine = Curl . create { sslVerify = false } ) { val elasticUser = getenv ( \"ELASTIC_USER\" ) ?. toKString () ?: DEFAULT_ELASTIC_USER val elasticPassword = getenv ( \"ELASTIC_PASSWORD\" ) ?. toKString () if ( ! elasticPassword . isNullOrEmpty ()) { auth = Auth . Basic ( elasticUser , elasticPassword ) } } Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.Refresh import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.bulk.IndexAction import dev.evo.elasticmagic.bulk.IdActionMeta import dev.evo.elasticmagic.doc.list suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = mutableListOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = mutableListOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = mutableListOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = mutableListOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.aggs.TermsAgg import dev.evo.elasticmagic.aggs.TermsAggResult import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.query.match import kotlinx.coroutines.runBlocking fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult < String > ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } fun main () = runBlocking { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg ( \"groups\" ) ) } Run the sample \u00b6 You can find fully working example inside samples And run it with as JVM application (of cause you need Elasticsearch available at localhost:9200 ): ./gradlew :samples:run or native: ./gradlew :samples:runDebugExecutableNative","title":"Home"},{"location":"#welcome-to-elasticmagic","text":"Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk","title":"Welcome to Elasticmagic"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#setup","text":"Add following dependencies in your build.gradle.kts script: repositories { mavenCentral () } val elasticmagicVersion = \"0.0.19-35-g1e1feb6\" val ktorVersion = \"2.2.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-kotlinx-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) }","title":"Setup"},{"location":"#usage","text":"First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.kotlinx.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport const val DEFAULT_ELASTIC_URL = \"http://localhost:9200\" const val DEFAULT_ELASTIC_USER = \"elastic\" expect val esTransport : ElasticsearchKtorTransport val cluster = ElasticsearchCluster ( esTransport , serde = JsonSerde ) val userIndex = cluster [ \"elasticmagic-samples_user\" ] Any ElasticsearchCluster needs an ElasticsearchTransport . We will use the ElasticsearchKtorTransport that utilises Ktor http client. Here are examples of creating transports for the cluster. JVM: package samples.started import dev.evo.elasticmagic.transport.Auth import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import dev.evo.elasticmagic.transport.Request import dev.evo.elasticmagic.transport.Response import dev.evo.elasticmagic.transport.PlainRequest import dev.evo.elasticmagic.transport.PlainResponse import dev.evo.elasticmagic.transport.Tracker import io.ktor.client.engine.cio.CIO import java.security.cert.X509Certificate import javax.net.ssl.X509TrustManager import kotlin.time.Duration import kotlin.getOrThrow actual val esTransport = ElasticsearchKtorTransport ( System . getenv ( \"ELASTIC_URL\" ) ?: DEFAULT_ELASTIC_URL , engine = CIO . create { https { trustManager = object : X509TrustManager { override fun checkClientTrusted ( chain : Array < out X509Certificate >? , authType : String? ) {} override fun checkServerTrusted ( chain : Array < out X509Certificate >? , authType : String? ) {} override fun getAcceptedIssuers (): Array < X509Certificate >? = null } } } ) { val elasticUser = System . getenv ( \"ELASTIC_USER\" ) ?: DEFAULT_ELASTIC_USER val elasticPassword = System . getenv ( \"ELASTIC_PASSWORD\" ) if ( ! elasticPassword . isNullOrEmpty ()) { auth = Auth . Basic ( elasticUser , elasticPassword ) } if ( System . getenv ( \"ELASTICMAGIC_DEBUG\" ) != null ) { trackers = listOf { object : Tracker { override fun requiresTextContent ( request : Request <* , * , *> ) = true override fun onRequest ( request : PlainRequest ) { println ( \">>>\" ) println ( \" ${ request . method } ${ request . path . ifEmpty { \"/\" } } \" ) println ( request . textContent ) } override fun onResponse ( responseResult : Result < PlainResponse > , duration : Duration ) { responseResult . onSuccess { response -> println ( \"<<< ${ response . statusCode } : ${ duration } \" ) response . headers . forEach { header -> println ( \"< ${ header . key } : ${ header . value } \" ) } println ( response . contentType ) println ( response . content ) } . onFailure { exception -> println ( \"!!! $ exception \" ) } } } } } } Native: package samples.started import dev.evo.elasticmagic.serde.kotlinx.JsonSerde import dev.evo.elasticmagic.transport.Auth import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.curl.Curl import kotlinx.cinterop.toKString import platform.posix.getenv actual val esTransport = ElasticsearchKtorTransport ( getenv ( \"ELASTIC_URL\" ) ?. toKString () ?: DEFAULT_ELASTIC_URL , engine = Curl . create { sslVerify = false } ) { val elasticUser = getenv ( \"ELASTIC_USER\" ) ?. toKString () ?: DEFAULT_ELASTIC_USER val elasticPassword = getenv ( \"ELASTIC_PASSWORD\" ) ?. toKString () if ( ! elasticPassword . isNullOrEmpty ()) { auth = Auth . Basic ( elasticUser , elasticPassword ) } } Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.Refresh import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.bulk.IndexAction import dev.evo.elasticmagic.bulk.IdActionMeta import dev.evo.elasticmagic.doc.list suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = mutableListOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = mutableListOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = mutableListOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = mutableListOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.aggs.TermsAgg import dev.evo.elasticmagic.aggs.TermsAggResult import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.query.match import kotlinx.coroutines.runBlocking fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult < String > ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } fun main () = runBlocking { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg ( \"groups\" ) ) }","title":"Usage"},{"location":"#run-the-sample","text":"You can find fully working example inside samples And run it with as JVM application (of cause you need Elasticsearch available at localhost:9200 ): ./gradlew :samples:run or native: ./gradlew :samples:runDebugExecutableNative","title":"Run the sample"},{"location":"docsource/","text":"Document source \u00b6 Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) } Dynamic \u00b6 The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = mutableListOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = mutableListOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = mutableListOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten () User defined \u00b6 This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.doc.DocSource import samples.docsource.UserDoc // Explicit types are specified for clarity. You can totally omit them class RoleDocSource : DocSource () { var name : String by UserDoc . roles . name . required () var permissions : MutableList < String > by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { // id and login fields must be present var id : Int by UserDoc . id . required () var login : String by UserDoc . login . required () // If groups field is missing or null default value will be used var groups : MutableList < String > by UserDoc . groups . required (). list (). default { mutableListOf () } // Optional list of a required RoleDocSource instances var roles : MutableList < RoleDocSource >? by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val nobody = UserDocSource (). apply { id = 65535 login = \"nobody\" } val nobodyHasGroups = nobody . groups . isEmpty () val root = UserDocSource (). apply { id = 0 login = \"root\" groups = mutableListOf ( \"root\" , \"wheel\" ) roles = mutableListOf ( RoleDocSource (). apply { name = \"superuser\" permissions = mutableListOf ( \"*\" ) } ) } val rootId : Int = root . id val rootPermissions : List < String >? = root . roles ?. flatMap { it . permissions }","title":"Document source"},{"location":"docsource/#document-source","text":"Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) }","title":"Document source"},{"location":"docsource/#dynamic","text":"The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = mutableListOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = mutableListOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = mutableListOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten ()","title":"Dynamic"},{"location":"docsource/#user-defined","text":"This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.doc.DocSource import samples.docsource.UserDoc // Explicit types are specified for clarity. You can totally omit them class RoleDocSource : DocSource () { var name : String by UserDoc . roles . name . required () var permissions : MutableList < String > by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { // id and login fields must be present var id : Int by UserDoc . id . required () var login : String by UserDoc . login . required () // If groups field is missing or null default value will be used var groups : MutableList < String > by UserDoc . groups . required (). list (). default { mutableListOf () } // Optional list of a required RoleDocSource instances var roles : MutableList < RoleDocSource >? by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val nobody = UserDocSource (). apply { id = 65535 login = \"nobody\" } val nobodyHasGroups = nobody . groups . isEmpty () val root = UserDocSource (). apply { id = 0 login = \"root\" groups = mutableListOf ( \"root\" , \"wheel\" ) roles = mutableListOf ( RoleDocSource (). apply { name = \"superuser\" permissions = mutableListOf ( \"*\" ) } ) } val rootId : Int = root . id val rootPermissions : List < String >? = root . roles ?. flatMap { it . permissions }","title":"User defined"},{"location":"document/","text":"Document (aka mapping) \u00b6 Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types Simple fields \u00b6 General way \u00b6 You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.types.BooleanType import dev.evo.elasticmagic.types.IntType import dev.evo.elasticmagic.types.KeywordType import dev.evo.elasticmagic.types.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id ) Using shortcuts \u00b6 There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here Enums \u00b6 It is possible to map field values to kotlin enums. Use enum extension function for that: package samples.document.enums import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.enum enum class UserStatus { ACTIVE , LOCKED , NO_PASSWORD } object UserDoc : Document () { val status by keyword (). enum < UserStatus > () } Now you are able to use enum variants in your search queries: package samples.document.enums import dev.evo.elasticmagic.SearchQuery val q = SearchQuery () . filter ( UserDoc . status . eq ( UserStatus . ACTIVE ) ) Sub fields \u00b6 It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to use sub-fields twice. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more Object fields \u00b6 Object \u00b6 Object type just represents a hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class GroupDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API Nested \u00b6 Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.query.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API Parent-child relationship \u00b6 Parent/child relationship allows you to define a link between documents inside an index. Join field \u00b6 package samples.document.join import dev.evo.elasticmagic.doc.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API Meta fields \u00b6 Elasticsearch mapping has metadata fields . Some of those fields can be customized. In following example we make a value for _routing field required and keep only name field in document source: package samples.document.meta import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MetaFields object ProductDoc : Document () { val name by text () val companyId by int () override val meta = object : MetaFields () { override val routing by RoutingField ( required = true ) override val source by SourceField ( includes = listOf ( \"name\" )) } } Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw routing_missing_exceptions . Merge multiple documents \u00b6 To create a mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.doc.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Document (aka mapping)"},{"location":"document/#document-aka-mapping","text":"Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types","title":"Document (aka mapping)"},{"location":"document/#simple-fields","text":"","title":"Simple fields"},{"location":"document/#general-way","text":"You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.types.BooleanType import dev.evo.elasticmagic.types.IntType import dev.evo.elasticmagic.types.KeywordType import dev.evo.elasticmagic.types.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id )","title":"General way"},{"location":"document/#using-shortcuts","text":"There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here","title":"Using shortcuts"},{"location":"document/#enums","text":"It is possible to map field values to kotlin enums. Use enum extension function for that: package samples.document.enums import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.enum enum class UserStatus { ACTIVE , LOCKED , NO_PASSWORD } object UserDoc : Document () { val status by keyword (). enum < UserStatus > () } Now you are able to use enum variants in your search queries: package samples.document.enums import dev.evo.elasticmagic.SearchQuery val q = SearchQuery () . filter ( UserDoc . status . eq ( UserStatus . ACTIVE ) )","title":"Enums"},{"location":"document/#sub-fields","text":"It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to use sub-fields twice. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more","title":"Sub fields"},{"location":"document/#object-fields","text":"","title":"Object fields"},{"location":"document/#object","text":"Object type just represents a hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class GroupDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API","title":"Object"},{"location":"document/#nested","text":"Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.query.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API","title":"Nested"},{"location":"document/#parent-child-relationship","text":"Parent/child relationship allows you to define a link between documents inside an index.","title":"Parent-child relationship"},{"location":"document/#join-field","text":"package samples.document.join import dev.evo.elasticmagic.doc.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API","title":"Join field"},{"location":"document/#meta-fields","text":"Elasticsearch mapping has metadata fields . Some of those fields can be customized. In following example we make a value for _routing field required and keep only name field in document source: package samples.document.meta import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MetaFields object ProductDoc : Document () { val name by text () val companyId by int () override val meta = object : MetaFields () { override val routing by RoutingField ( required = true ) override val source by SourceField ( includes = listOf ( \"name\" )) } } Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw routing_missing_exceptions .","title":"Meta fields"},{"location":"document/#merge-multiple-documents","text":"To create a mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.doc.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Merge multiple documents"},{"location":"query-filters/","text":"Query Filters \u00b6 Query filters allow you to describe search query modifications declaratively. It is possible to filter, sort, paginate and build facets using query filters. Let's describe our new document: package samples.qf import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.enum enum class BikeKind { BMX , MTB , CITY , ROAD , CYCLOCROSS , GRAVEL , EBIKE ; } object BikeDoc : Document () { val price by float () val manufacturer by keyword () val model by text () val kind by keyword (). enum ( BikeKind :: name ) val weight by float () } Now we can describe query filters for the BikeDoc : package samples.qf import dev.evo.elasticmagic.qf.FacetFilter import dev.evo.elasticmagic.qf.FacetRangeFilter import dev.evo.elasticmagic.qf.PageFilter import dev.evo.elasticmagic.qf.QueryFilters import dev.evo.elasticmagic.qf.SortFilter import dev.evo.elasticmagic.qf.SortFilterValue object BikeQueryFilters : QueryFilters () { val price by FacetRangeFilter ( BikeDoc . price ) val manufacturer by FacetFilter ( BikeDoc . manufacturer ) val kind by FacetFilter ( BikeDoc . kind ) val weight by FacetRangeFilter ( BikeDoc . weight ) val sort by SortFilter ( SortFilterValue ( \"price\" , listOf ( BikeDoc . price )), SortFilterValue ( \"-price\" , listOf ( BikeDoc . price . desc ())), SortFilterValue ( \"weight\" , listOf ( BikeDoc . weight )), ) val page by PageFilter () } To apply it to a search query you need query filter parameters. They are just a mapping where keys are a pair of filter name and an operation, and values are a list of strings. For example, it could be transformed from http query parameters. package samples.qf import dev.evo.elasticmagic.SearchQuery // You can imagine it could be converted from following http query parameters: // manufacturer=Giant&manufacturer=Cannondale& // kind=CITY&kind=CYCLOCROSS&kind=GRAVEL& // price__lte=2000& // sort=weight& // page=2& val qfParams = mapOf ( listOf ( \"manufacturer\" ) to listOf ( \"Giant\" , \"Cannondale\" ), listOf ( \"kind\" ) to listOf ( \"CITY\" , \"CYCLOCROSS\" , \"GRAVEL\" ), listOf ( \"price\" , \"lte\" ) to listOf ( \"2000\" ), listOf ( \"sort\" ) to listOf ( \"weight\" ), listOf ( \"page\" ) to listOf ( \"2\" ), ) val searchQuery = SearchQuery () val appliedFilters = BikeQueryFilters . apply ( searchQuery , qfParams ) // Now searchQuery is filtered, sorted, paginated and corresponding aggregations // to calculate facets are added After executing query we are able to process its results: package samples.qf import dev.evo.elasticmagic.doc.DynDocSource import samples.started.cluster suspend fun process () { val filtersResult = appliedFilters . processResult ( searchQuery . execute ( cluster [ \"elasticmagic-samples_bike\" ] ) ) val manufacturerFacet = filtersResult [ BikeQueryFilters . manufacturer ] println ( \"Manufacturers:\" ) for ( manufacturer in manufacturerFacet ) { val selectedMark = if ( manufacturer . selected ) \"x\" else \" \" println ( \" [ $ selectedMark ] ${ manufacturer . value } ( ${ manufacturer . count } )\" ) } println () val kindFacet = filtersResult [ BikeQueryFilters . kind ] println ( \"Kinds:\" ) for ( kind in kindFacet ) { val selectedMark = if ( kind . selected ) \"x\" else \" \" println ( \" [ $ selectedMark ] ${ kind . value } ( ${ kind . count } )\" ) } println () val page = filtersResult [ BikeQueryFilters . page ] println ( \"Results:\" ) for ( hit in page ) { val source = requireNotNull ( hit . source ) as DynDocSource println ( \" ${ source [ BikeDoc . manufacturer ] } ${ source [ BikeDoc . model ] } - ${ source [ BikeDoc . price ] } \" ) } println () println ( \"Current page: ${ page . page } \" ) println ( \"Total pages: ${ page . totalPages } \" ) println () } Run a full-fledged query filters sample \u00b6 JVM version: ./gradlew :samples:runBikeshop -q --console = plain Native version: ./gradlew :samples:linkBikeshopDebugExecutableNative ./samples/build/bin/native/bikeshopDebugExecutable/bikeshop.kexe Both versions support following environment variables: ELASTIC_URL - URL to your Elasticsearch cluster. Default is http://localhost:9200 . If you want to use TLS change it to https://localhost:9200 . Elasticsearch 8.x and Opensearch 2.x turn on TLS by default. ELASTIC_USER - user for a basic authentication. Default is elastic . Change it to admin if you use Opensearch. ELASTIC_PASSWORD - if this variable is set, basic authentication will be used. Set it to a real password of your cluster or leave empty if your cluster doesn't require authentication. Password for default configuration of Elasticsearch 8.x can be found in logs. Default password for Opensearch 2.x is admin .","title":"Query Filters"},{"location":"query-filters/#query-filters","text":"Query filters allow you to describe search query modifications declaratively. It is possible to filter, sort, paginate and build facets using query filters. Let's describe our new document: package samples.qf import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.enum enum class BikeKind { BMX , MTB , CITY , ROAD , CYCLOCROSS , GRAVEL , EBIKE ; } object BikeDoc : Document () { val price by float () val manufacturer by keyword () val model by text () val kind by keyword (). enum ( BikeKind :: name ) val weight by float () } Now we can describe query filters for the BikeDoc : package samples.qf import dev.evo.elasticmagic.qf.FacetFilter import dev.evo.elasticmagic.qf.FacetRangeFilter import dev.evo.elasticmagic.qf.PageFilter import dev.evo.elasticmagic.qf.QueryFilters import dev.evo.elasticmagic.qf.SortFilter import dev.evo.elasticmagic.qf.SortFilterValue object BikeQueryFilters : QueryFilters () { val price by FacetRangeFilter ( BikeDoc . price ) val manufacturer by FacetFilter ( BikeDoc . manufacturer ) val kind by FacetFilter ( BikeDoc . kind ) val weight by FacetRangeFilter ( BikeDoc . weight ) val sort by SortFilter ( SortFilterValue ( \"price\" , listOf ( BikeDoc . price )), SortFilterValue ( \"-price\" , listOf ( BikeDoc . price . desc ())), SortFilterValue ( \"weight\" , listOf ( BikeDoc . weight )), ) val page by PageFilter () } To apply it to a search query you need query filter parameters. They are just a mapping where keys are a pair of filter name and an operation, and values are a list of strings. For example, it could be transformed from http query parameters. package samples.qf import dev.evo.elasticmagic.SearchQuery // You can imagine it could be converted from following http query parameters: // manufacturer=Giant&manufacturer=Cannondale& // kind=CITY&kind=CYCLOCROSS&kind=GRAVEL& // price__lte=2000& // sort=weight& // page=2& val qfParams = mapOf ( listOf ( \"manufacturer\" ) to listOf ( \"Giant\" , \"Cannondale\" ), listOf ( \"kind\" ) to listOf ( \"CITY\" , \"CYCLOCROSS\" , \"GRAVEL\" ), listOf ( \"price\" , \"lte\" ) to listOf ( \"2000\" ), listOf ( \"sort\" ) to listOf ( \"weight\" ), listOf ( \"page\" ) to listOf ( \"2\" ), ) val searchQuery = SearchQuery () val appliedFilters = BikeQueryFilters . apply ( searchQuery , qfParams ) // Now searchQuery is filtered, sorted, paginated and corresponding aggregations // to calculate facets are added After executing query we are able to process its results: package samples.qf import dev.evo.elasticmagic.doc.DynDocSource import samples.started.cluster suspend fun process () { val filtersResult = appliedFilters . processResult ( searchQuery . execute ( cluster [ \"elasticmagic-samples_bike\" ] ) ) val manufacturerFacet = filtersResult [ BikeQueryFilters . manufacturer ] println ( \"Manufacturers:\" ) for ( manufacturer in manufacturerFacet ) { val selectedMark = if ( manufacturer . selected ) \"x\" else \" \" println ( \" [ $ selectedMark ] ${ manufacturer . value } ( ${ manufacturer . count } )\" ) } println () val kindFacet = filtersResult [ BikeQueryFilters . kind ] println ( \"Kinds:\" ) for ( kind in kindFacet ) { val selectedMark = if ( kind . selected ) \"x\" else \" \" println ( \" [ $ selectedMark ] ${ kind . value } ( ${ kind . count } )\" ) } println () val page = filtersResult [ BikeQueryFilters . page ] println ( \"Results:\" ) for ( hit in page ) { val source = requireNotNull ( hit . source ) as DynDocSource println ( \" ${ source [ BikeDoc . manufacturer ] } ${ source [ BikeDoc . model ] } - ${ source [ BikeDoc . price ] } \" ) } println () println ( \"Current page: ${ page . page } \" ) println ( \"Total pages: ${ page . totalPages } \" ) println () }","title":"Query Filters"},{"location":"query-filters/#run-a-full-fledged-query-filters-sample","text":"JVM version: ./gradlew :samples:runBikeshop -q --console = plain Native version: ./gradlew :samples:linkBikeshopDebugExecutableNative ./samples/build/bin/native/bikeshopDebugExecutable/bikeshop.kexe Both versions support following environment variables: ELASTIC_URL - URL to your Elasticsearch cluster. Default is http://localhost:9200 . If you want to use TLS change it to https://localhost:9200 . Elasticsearch 8.x and Opensearch 2.x turn on TLS by default. ELASTIC_USER - user for a basic authentication. Default is elastic . Change it to admin if you use Opensearch. ELASTIC_PASSWORD - if this variable is set, basic authentication will be used. Set it to a real password of your cluster or leave empty if your cluster doesn't require authentication. Password for default configuration of Elasticsearch 8.x can be found in logs. Default password for Opensearch 2.x is admin .","title":"Run a full-fledged query filters sample"},{"location":"querying/","text":"Querying \u00b6 To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val isActive by boolean ( \"is_active\" ) val groups by keyword () val rating by float () val about by text () } Query \u00b6 You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match var q = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match val q2 = q . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) See full list of available query expressions . Cloning \u00b6 In the last example q and q2 variables point to the same object. For efficiency all SearchQuery methods modify current instance and return it for chaining method calls. If you want to get independent query instance you should clone it explicitly: package samples.querying import dev.evo.elasticmagic.query.match val clonedQuery = q . clone () . query ( UserDoc . about . match ( \"fake\" )) Now you can modify clonedQuery without touching its ancestor q . Filtering \u00b6 Using filter method you can filter your query. All filters passed to the filter method will be combined using AND operation. package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.match // Select only active users that id is not equal 0 val activeUsersQuery = q . filter ( UserDoc . isActive . eq ( true )) . filter ( UserDoc . id . ne ( 0 )) // The same as above val activeUsersQuery2 = q . filter ( UserDoc . isActive . eq ( true ), UserDoc . id . ne ( 0 ) ) // If you need one condition OR another use Bool.should expression. // In the following example we select non-active users OR \"fake\" users val activeUsersQuery3 = q . filter ( Bool . should ( UserDoc . isActive . ne ( true ), UserDoc . about . match ( \"fake\" ) ) ) See Query Filter Context Sorting \u00b6 sort method has 2 flavors: a shortcut that accepts document fields and full-featured version accepting Sort expressions package samples.querying import dev.evo.elasticmagic.query.Sort // Sort by user id with ascending order val sortedByIdQuery = q . sort ( UserDoc . id ) // Sort by user id descending val sortedByIdDescQuery = q . sort ( UserDoc . id . desc ()) // Sort by several criteria val multipleSortedQuery = q . sort ( UserDoc . isActive . desc (), UserDoc . id . asc ()) // Use Sort explicitly to customize sort behaviour val sortedByRatingQuery = q . sort ( Sort ( UserDoc . rating , missing = Sort . Missing . First )) See: Sort Search Results Aggregations \u00b6 Use aggs method to define aggregations: package samples.querying import dev.evo.elasticmagic.aggs.AvgAgg import dev.evo.elasticmagic.aggs.HistogramAgg import dev.evo.elasticmagic.aggs.TermsAgg // Build aggregations by groups and calculate average rating as well as // build histogram by rating for every group val ratingHistogramQuery = q . aggs ( \"groups\" to TermsAgg ( UserDoc . groups , aggs = mapOf ( \"avg_rating\" to AvgAgg ( UserDoc . rating ), \"rating_histogram\" to HistogramAgg ( UserDoc . rating , interval = 10.0F ), ) ) ) See Search Aggregations Query Nodes \u00b6 Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to replace parts of the query after creation using special query expressions and queryNode method: package samples.querying import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MappingField import dev.evo.elasticmagic.doc.SubDocument import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.DisMax import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match import dev.evo.elasticmagic.query.NodeHandle import dev.evo.elasticmagic.query.QueryExpressionNode import kotlin.random.Random class TranslationDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val en by text () val de by text () val ru by text () } object QuestionDoc : Document () { val title by obj ( :: TranslationDoc ) val text by obj ( :: TranslationDoc ) val rating by float () val votes by int () } val scoringHandle = NodeHandle < FunctionScore > () val langHandle = NodeHandle < DisMax > () val searchTerm = \"hello world\" val skeletonQuery = SearchQuery ( QueryExpressionNode ( scoringHandle , FunctionScore ( QueryExpressionNode ( langHandle , DisMax ( queries = listOf ( Bool . should ( QuestionDoc . title . en . match ( searchTerm ), QuestionDoc . text . en . match ( searchTerm ), ) ), ) ), functions = listOf ( FunctionScore . FieldValueFactor ( QuestionDoc . rating ), ), scoreMode = FunctionScore . ScoreMode . MULTIPLY , ) ) ) val boostByNumberOfVotes = Random . nextBoolean () var boostedQuery = if ( boostByNumberOfVotes ) { skeletonQuery . queryNode ( scoringHandle ) { node -> node . copy ( functions = node . functions + listOf ( FunctionScore . Weight ( 1.1F , filter = QuestionDoc . votes . range ( gte = 10 , lt = 50 ) ), FunctionScore . Weight ( 1.5F , filter = QuestionDoc . votes . gte ( 50 ) ), ) ) } } else { skeletonQuery } val additionalLanguages = listOf ( \"de\" , \"ru\" ) val userLang = additionalLanguages [ Random . nextInt ( additionalLanguages . size ) ] val additionalLangFields : List < MappingField < String >> = listOfNotNull ( QuestionDoc . title . getFieldByName ( userLang ), QuestionDoc . text . getFieldByName ( userLang ), ) val langQuery = if ( additionalLangFields . isNotEmpty ()) { boostedQuery . queryNode ( langHandle ) { node -> node . copy ( queries = node . queries + listOf ( Bool . should ( * additionalLangFields . map { it . match ( searchTerm ) }. toTypedArray () ) ) ) } } else { boostedQuery }","title":"Querying"},{"location":"querying/#querying","text":"To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val isActive by boolean ( \"is_active\" ) val groups by keyword () val rating by float () val about by text () }","title":"Querying"},{"location":"querying/#query","text":"You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match var q = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match val q2 = q . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) See full list of available query expressions .","title":"Query"},{"location":"querying/#cloning","text":"In the last example q and q2 variables point to the same object. For efficiency all SearchQuery methods modify current instance and return it for chaining method calls. If you want to get independent query instance you should clone it explicitly: package samples.querying import dev.evo.elasticmagic.query.match val clonedQuery = q . clone () . query ( UserDoc . about . match ( \"fake\" )) Now you can modify clonedQuery without touching its ancestor q .","title":"Cloning"},{"location":"querying/#filtering","text":"Using filter method you can filter your query. All filters passed to the filter method will be combined using AND operation. package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.match // Select only active users that id is not equal 0 val activeUsersQuery = q . filter ( UserDoc . isActive . eq ( true )) . filter ( UserDoc . id . ne ( 0 )) // The same as above val activeUsersQuery2 = q . filter ( UserDoc . isActive . eq ( true ), UserDoc . id . ne ( 0 ) ) // If you need one condition OR another use Bool.should expression. // In the following example we select non-active users OR \"fake\" users val activeUsersQuery3 = q . filter ( Bool . should ( UserDoc . isActive . ne ( true ), UserDoc . about . match ( \"fake\" ) ) ) See Query Filter Context","title":"Filtering"},{"location":"querying/#sorting","text":"sort method has 2 flavors: a shortcut that accepts document fields and full-featured version accepting Sort expressions package samples.querying import dev.evo.elasticmagic.query.Sort // Sort by user id with ascending order val sortedByIdQuery = q . sort ( UserDoc . id ) // Sort by user id descending val sortedByIdDescQuery = q . sort ( UserDoc . id . desc ()) // Sort by several criteria val multipleSortedQuery = q . sort ( UserDoc . isActive . desc (), UserDoc . id . asc ()) // Use Sort explicitly to customize sort behaviour val sortedByRatingQuery = q . sort ( Sort ( UserDoc . rating , missing = Sort . Missing . First )) See: Sort Search Results","title":"Sorting"},{"location":"querying/#aggregations","text":"Use aggs method to define aggregations: package samples.querying import dev.evo.elasticmagic.aggs.AvgAgg import dev.evo.elasticmagic.aggs.HistogramAgg import dev.evo.elasticmagic.aggs.TermsAgg // Build aggregations by groups and calculate average rating as well as // build histogram by rating for every group val ratingHistogramQuery = q . aggs ( \"groups\" to TermsAgg ( UserDoc . groups , aggs = mapOf ( \"avg_rating\" to AvgAgg ( UserDoc . rating ), \"rating_histogram\" to HistogramAgg ( UserDoc . rating , interval = 10.0F ), ) ) ) See Search Aggregations","title":"Aggregations"},{"location":"querying/#query-nodes","text":"Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to replace parts of the query after creation using special query expressions and queryNode method: package samples.querying import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MappingField import dev.evo.elasticmagic.doc.SubDocument import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.DisMax import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match import dev.evo.elasticmagic.query.NodeHandle import dev.evo.elasticmagic.query.QueryExpressionNode import kotlin.random.Random class TranslationDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val en by text () val de by text () val ru by text () } object QuestionDoc : Document () { val title by obj ( :: TranslationDoc ) val text by obj ( :: TranslationDoc ) val rating by float () val votes by int () } val scoringHandle = NodeHandle < FunctionScore > () val langHandle = NodeHandle < DisMax > () val searchTerm = \"hello world\" val skeletonQuery = SearchQuery ( QueryExpressionNode ( scoringHandle , FunctionScore ( QueryExpressionNode ( langHandle , DisMax ( queries = listOf ( Bool . should ( QuestionDoc . title . en . match ( searchTerm ), QuestionDoc . text . en . match ( searchTerm ), ) ), ) ), functions = listOf ( FunctionScore . FieldValueFactor ( QuestionDoc . rating ), ), scoreMode = FunctionScore . ScoreMode . MULTIPLY , ) ) ) val boostByNumberOfVotes = Random . nextBoolean () var boostedQuery = if ( boostByNumberOfVotes ) { skeletonQuery . queryNode ( scoringHandle ) { node -> node . copy ( functions = node . functions + listOf ( FunctionScore . Weight ( 1.1F , filter = QuestionDoc . votes . range ( gte = 10 , lt = 50 ) ), FunctionScore . Weight ( 1.5F , filter = QuestionDoc . votes . gte ( 50 ) ), ) ) } } else { skeletonQuery } val additionalLanguages = listOf ( \"de\" , \"ru\" ) val userLang = additionalLanguages [ Random . nextInt ( additionalLanguages . size ) ] val additionalLangFields : List < MappingField < String >> = listOfNotNull ( QuestionDoc . title . getFieldByName ( userLang ), QuestionDoc . text . getFieldByName ( userLang ), ) val langQuery = if ( additionalLangFields . isNotEmpty ()) { boostedQuery . queryNode ( langHandle ) { node -> node . copy ( queries = node . queries + listOf ( Bool . should ( * additionalLangFields . map { it . match ( searchTerm ) }. toTypedArray () ) ) ) } } else { boostedQuery }","title":"Query Nodes"}]}