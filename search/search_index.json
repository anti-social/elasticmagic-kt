{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Elasticmagic \u00b6 Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk Getting started \u00b6 Setup \u00b6 Add following dependencies in your build.gradle.kts script: repositories { mavenCentral () } val elasticmagicVersion = \"0.0.5\" val ktorVersion = \"1.5.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-serialization-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) } Usage \u00b6 First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.serialization.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.cio.CIO val esTransport = ElasticsearchKtorTransport ( \"http://localhost:9200\" , serde = JsonSerde , engine = CIO . create {} ) val cluster = ElasticsearchCluster ( esTransport , JsonSerde ) val userIndex = cluster [ \"user\" ] Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.IndexAction import dev.evo.elasticmagic.doc.IdentActionMeta import dev.evo.elasticmagic.doc.list import dev.evo.elasticmagic.doc.Refresh suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = listOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdentActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.aggs.TermsAgg import dev.evo.elasticmagic.aggs.TermsAggResult import dev.evo.elasticmagic.query.match fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } suspend fun main () { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg ( \"groups\" ) ) } Run the sample \u00b6 You can find fully working example inside samples And run it with (of cause you need Elasticsearch available at localhost:9200 ): ./gradlew :samples:run","title":"Home"},{"location":"#welcome-to-elasticmagic","text":"Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk","title":"Welcome to Elasticmagic"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#setup","text":"Add following dependencies in your build.gradle.kts script: repositories { mavenCentral () } val elasticmagicVersion = \"0.0.5\" val ktorVersion = \"1.5.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-serialization-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) }","title":"Setup"},{"location":"#usage","text":"First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.serialization.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.cio.CIO val esTransport = ElasticsearchKtorTransport ( \"http://localhost:9200\" , serde = JsonSerde , engine = CIO . create {} ) val cluster = ElasticsearchCluster ( esTransport , JsonSerde ) val userIndex = cluster [ \"user\" ] Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.IndexAction import dev.evo.elasticmagic.doc.IdentActionMeta import dev.evo.elasticmagic.doc.list import dev.evo.elasticmagic.doc.Refresh suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = listOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdentActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.aggs.TermsAgg import dev.evo.elasticmagic.aggs.TermsAggResult import dev.evo.elasticmagic.query.match fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } suspend fun main () { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg ( \"groups\" ) ) }","title":"Usage"},{"location":"#run-the-sample","text":"You can find fully working example inside samples And run it with (of cause you need Elasticsearch available at localhost:9200 ): ./gradlew :samples:run","title":"Run the sample"},{"location":"docsource/","text":"Document source \u00b6 Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) } Dynamic \u00b6 The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = listOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = listOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten () User defined \u00b6 This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.doc.DocSource import samples.docsource.UserDoc // Explicit types are specified for clarity. You can totally omit them class RoleDocSource : DocSource () { var name : String by UserDoc . roles . name . required () var permissions : List < String > by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { // id and login fields must be present var id : Int by UserDoc . id . required () var login : String by UserDoc . login . required () // If groups field is missing or null default value will be used var groups : List < String > by UserDoc . groups . required (). list (). default { emptyList () } // Optional list of a required RoleDocSource instances var roles : List < RoleDocSource >? by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val nobody = UserDocSource (). apply { id = 65535 login = \"nobody\" } val nobodyHasGroups = nobody . groups . isEmpty () val root = UserDocSource (). apply { id = 0 login = \"root\" groups = listOf ( \"root\" , \"wheel\" ) roles = listOf ( RoleDocSource (). apply { name = \"superuser\" permissions = listOf ( \"*\" ) } ) } val rootId : Int = root . id val rootPermissions : List < String >? = root . roles ?. flatMap { it . permissions }","title":"Document source"},{"location":"docsource/#document-source","text":"Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) }","title":"Document source"},{"location":"docsource/#dynamic","text":"The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.doc.DynDocSource import dev.evo.elasticmagic.doc.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = listOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = listOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten ()","title":"Dynamic"},{"location":"docsource/#user-defined","text":"This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.doc.DocSource import samples.docsource.UserDoc // Explicit types are specified for clarity. You can totally omit them class RoleDocSource : DocSource () { var name : String by UserDoc . roles . name . required () var permissions : List < String > by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { // id and login fields must be present var id : Int by UserDoc . id . required () var login : String by UserDoc . login . required () // If groups field is missing or null default value will be used var groups : List < String > by UserDoc . groups . required (). list (). default { emptyList () } // Optional list of a required RoleDocSource instances var roles : List < RoleDocSource >? by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val nobody = UserDocSource (). apply { id = 65535 login = \"nobody\" } val nobodyHasGroups = nobody . groups . isEmpty () val root = UserDocSource (). apply { id = 0 login = \"root\" groups = listOf ( \"root\" , \"wheel\" ) roles = listOf ( RoleDocSource (). apply { name = \"superuser\" permissions = listOf ( \"*\" ) } ) } val rootId : Int = root . id val rootPermissions : List < String >? = root . roles ?. flatMap { it . permissions }","title":"User defined"},{"location":"document/","text":"Document (aka mapping) \u00b6 Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types Simple fields \u00b6 General way \u00b6 You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.BooleanType import dev.evo.elasticmagic.doc.IntType import dev.evo.elasticmagic.doc.KeywordType import dev.evo.elasticmagic.doc.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id ) Using shortcuts \u00b6 There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here Sub fields \u00b6 It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to use sub-fields twice. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more Object fields \u00b6 Object \u00b6 Object type just represent hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class GroupDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API Nested \u00b6 Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.query.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API Parent-child relationship \u00b6 Parent/child relationship allows you to define a link between documents inside an index. Join field \u00b6 package samples.document.join import dev.evo.elasticmagic.doc.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API Meta fields \u00b6 Elasticsearch document has some metadata fields . Some of those fields can be customized. In following example we make a value for _routing field required and keep only name field in document source: package samples.document.meta import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MetaFields object ProductDoc : Document () { val name by text () val companyId by int () override val meta = object : MetaFields () { override val routing by RoutingField ( required = true ) override val source by SourceField ( includes = listOf ( \"name\" )) } } Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw routing_missing_exceptions . Merge multiple documents \u00b6 To create mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.doc.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Document (aka mapping)"},{"location":"document/#document-aka-mapping","text":"Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types","title":"Document (aka mapping)"},{"location":"document/#simple-fields","text":"","title":"Simple fields"},{"location":"document/#general-way","text":"You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.BooleanType import dev.evo.elasticmagic.doc.IntType import dev.evo.elasticmagic.doc.KeywordType import dev.evo.elasticmagic.doc.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id )","title":"General way"},{"location":"document/#using-shortcuts","text":"There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here","title":"Using shortcuts"},{"location":"document/#sub-fields","text":"It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to use sub-fields twice. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.SubFields class AboutSubFields ( field : BoundField < String , String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more","title":"Sub fields"},{"location":"document/#object-fields","text":"","title":"Object fields"},{"location":"document/#object","text":"Object type just represent hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class GroupDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API","title":"Object"},{"location":"document/#nested","text":"Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.query.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.SubDocument class RoleDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API","title":"Nested"},{"location":"document/#parent-child-relationship","text":"Parent/child relationship allows you to define a link between documents inside an index.","title":"Parent-child relationship"},{"location":"document/#join-field","text":"package samples.document.join import dev.evo.elasticmagic.doc.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API","title":"Join field"},{"location":"document/#meta-fields","text":"Elasticsearch document has some metadata fields . Some of those fields can be customized. In following example we make a value for _routing field required and keep only name field in document source: package samples.document.meta import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.MetaFields object ProductDoc : Document () { val name by text () val companyId by int () override val meta = object : MetaFields () { override val routing by RoutingField ( required = true ) override val source by SourceField ( includes = listOf ( \"name\" )) } } Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw routing_missing_exceptions .","title":"Meta fields"},{"location":"document/#merge-multiple-documents","text":"To create mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.doc.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Merge multiple documents"},{"location":"querying/","text":"Querying \u00b6 To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val isActive by boolean ( \"is_active\" ) val groups by keyword () val rating by float () val about by text () } Query \u00b6 You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match var q = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match val q2 = q . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) See full list of available query expressions . Cloning \u00b6 In the last example q and q2 variables point to the same object. For efficiency all SearchQuery methods modify current instance and return it for chaining method calls. If you want to get independent query instance you should clone it explicitly: package samples.querying import dev.evo.elasticmagic.query.match val clonedQuery = q . clone () . query ( UserDoc . about . match ( \"fake\" )) Now you can modify clonedQuery without touching its ancestor q . Filtering \u00b6 Using filter method you can filter your query. All filters passed to the filter method will be combined using AND operation. package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.match // Select only active users that id is not equal 0 val activeUsersQuery = q . filter ( UserDoc . isActive . eq ( true )) . filter ( UserDoc . id . ne ( 0 )) // The same as above val activeUsersQuery2 = q . filter ( UserDoc . isActive . eq ( true ), UserDoc . id . ne ( 0 ) ) // If you need one condition OR another use Bool.should expression. // In the following example we select non-active users OR \"fake\" users val activeUsersQuery3 = q . filter ( Bool . should ( UserDoc . isActive . ne ( true ), UserDoc . about . match ( \"fake\" ) ) ) See Query Filter Context Sorting \u00b6 sort method has 2 flavors: a shortcut that accepts document fields and full-featured version accepting Sort expressions package samples.querying import dev.evo.elasticmagic.query.Sort // Sort by user id with ascending order val sortedByIdQuery = q . sort ( UserDoc . id ) // Sort by user id descending val sortedByIdDescQuery = q . sort ( UserDoc . id . desc ()) // Sort by several criteria val multipleSortedQuery = q . sort ( UserDoc . isActive . desc (), UserDoc . id . asc ()) // Use Sort explicitly to customize sort behaviour val sortedByRatingQuery = q . sort ( Sort ( UserDoc . rating , missing = Sort . Missing . First )) See: Sort Search Results Aggregations \u00b6 Use aggs method to define aggregations: package samples.querying import dev.evo.elasticmagic.aggs.AvgAgg import dev.evo.elasticmagic.aggs.HistogramAgg import dev.evo.elasticmagic.aggs.TermsAgg // Build aggregations by groups and calculate average rating as well as // build histogram by rating for every group val ratingHistogramQuery = q . aggs ( \"groups\" to TermsAgg ( UserDoc . groups , aggs = mapOf ( \"avg_rating\" to AvgAgg ( UserDoc . rating ), \"rating_histogram\" to HistogramAgg ( UserDoc . rating , interval = 10.0F ), ) ) ) See Search Aggregations Query Nodes \u00b6 Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to modify parts of the query after creation using special query expressions and queryNode method: package samples.querying import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.AnyField import dev.evo.elasticmagic.doc.SubDocument import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.DisMaxNode import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.FunctionScoreNode import dev.evo.elasticmagic.query.NodeHandle import dev.evo.elasticmagic.query.match import kotlin.random.Random class TranslationDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val en by text () val de by text () val ru by text () } object QuestionDoc : Document () { val title by obj ( :: TranslationDoc ) val text by obj ( :: TranslationDoc ) val rating by float () val votes by int () } val scoringHandle = NodeHandle < FunctionScoreNode > () val langHandle = NodeHandle < DisMaxNode > () val searchTerm = \"hello world\" val skeletonQuery = SearchQuery ( FunctionScoreNode ( scoringHandle , DisMaxNode ( langHandle , queries = listOf ( Bool . should ( QuestionDoc . title . en . match ( searchTerm ), QuestionDoc . text . en . match ( searchTerm ), ) ), ), functions = listOf ( FunctionScore . FieldValueFactor ( QuestionDoc . rating ), ), scoreMode = FunctionScore . ScoreMode . MULTIPLY , ) ) val boostByNumberOfVotes = Random . nextBoolean () var boostedQuery = if ( boostByNumberOfVotes ) { skeletonQuery . queryNode ( scoringHandle ) { node -> node . functions += listOf ( FunctionScore . Weight ( 1.1 , filter = QuestionDoc . votes . range ( gte = 10 , lt = 50 ) ), FunctionScore . Weight ( 1.5 , filter = QuestionDoc . votes . gte ( 50 ) ), ) } } else { skeletonQuery } val additionalLanguages = listOf ( \"de\" , \"ru\" ) val userLang = additionalLanguages [ Random . nextInt ( additionalLanguages . size ) ] val additionalLangFields : List < AnyField < String >> = listOfNotNull ( QuestionDoc . title . getFieldByName ( userLang ), QuestionDoc . text . getFieldByName ( userLang ), ) val langQuery = if ( additionalLangFields . isNotEmpty ()) { boostedQuery . queryNode ( langHandle ) { node -> node . queries . add ( Bool . should ( * additionalLangFields . map { it . match ( searchTerm ) }. toTypedArray () ) ) } } else { boostedQuery }","title":"Querying"},{"location":"querying/#querying","text":"To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.doc.Document object UserDoc : Document () { val id by int () val isActive by boolean ( \"is_active\" ) val groups by keyword () val rating by float () val about by text () }","title":"Querying"},{"location":"querying/#query","text":"You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.query.match var q = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.match val q2 = q . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0F , ) ) ) ) See full list of available query expressions .","title":"Query"},{"location":"querying/#cloning","text":"In the last example q and q2 variables point to the same object. For efficiency all SearchQuery methods modify current instance and return it for chaining method calls. If you want to get independent query instance you should clone it explicitly: package samples.querying import dev.evo.elasticmagic.query.match val clonedQuery = q . clone () . query ( UserDoc . about . match ( \"fake\" )) Now you can modify clonedQuery without touching its ancestor q .","title":"Cloning"},{"location":"querying/#filtering","text":"Using filter method you can filter your query. All filters passed to the filter method will be combined using AND operation. package samples.querying import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.match // Select only active users that id is not equal 0 val activeUsersQuery = q . filter ( UserDoc . isActive . eq ( true )) . filter ( UserDoc . id . ne ( 0 )) // The same as above val activeUsersQuery2 = q . filter ( UserDoc . isActive . eq ( true ), UserDoc . id . ne ( 0 ) ) // If you need one condition OR another use Bool.should expression. // In the following example we select non-active users OR \"fake\" users val activeUsersQuery3 = q . filter ( Bool . should ( UserDoc . isActive . ne ( true ), UserDoc . about . match ( \"fake\" ) ) ) See Query Filter Context","title":"Filtering"},{"location":"querying/#sorting","text":"sort method has 2 flavors: a shortcut that accepts document fields and full-featured version accepting Sort expressions package samples.querying import dev.evo.elasticmagic.query.Sort // Sort by user id with ascending order val sortedByIdQuery = q . sort ( UserDoc . id ) // Sort by user id descending val sortedByIdDescQuery = q . sort ( UserDoc . id . desc ()) // Sort by several criteria val multipleSortedQuery = q . sort ( UserDoc . isActive . desc (), UserDoc . id . asc ()) // Use Sort explicitly to customize sort behaviour val sortedByRatingQuery = q . sort ( Sort ( UserDoc . rating , missing = Sort . Missing . First )) See: Sort Search Results","title":"Sorting"},{"location":"querying/#aggregations","text":"Use aggs method to define aggregations: package samples.querying import dev.evo.elasticmagic.aggs.AvgAgg import dev.evo.elasticmagic.aggs.HistogramAgg import dev.evo.elasticmagic.aggs.TermsAgg // Build aggregations by groups and calculate average rating as well as // build histogram by rating for every group val ratingHistogramQuery = q . aggs ( \"groups\" to TermsAgg ( UserDoc . groups , aggs = mapOf ( \"avg_rating\" to AvgAgg ( UserDoc . rating ), \"rating_histogram\" to HistogramAgg ( UserDoc . rating , interval = 10.0F ), ) ) ) See Search Aggregations","title":"Aggregations"},{"location":"querying/#query-nodes","text":"Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to modify parts of the query after creation using special query expressions and queryNode method: package samples.querying import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.doc.BaseDocSource import dev.evo.elasticmagic.doc.BoundField import dev.evo.elasticmagic.doc.Document import dev.evo.elasticmagic.doc.AnyField import dev.evo.elasticmagic.doc.SubDocument import dev.evo.elasticmagic.query.Bool import dev.evo.elasticmagic.query.DisMaxNode import dev.evo.elasticmagic.query.FunctionScore import dev.evo.elasticmagic.query.FunctionScoreNode import dev.evo.elasticmagic.query.NodeHandle import dev.evo.elasticmagic.query.match import kotlin.random.Random class TranslationDoc ( field : BoundField < BaseDocSource , Nothing > ) : SubDocument ( field ) { val en by text () val de by text () val ru by text () } object QuestionDoc : Document () { val title by obj ( :: TranslationDoc ) val text by obj ( :: TranslationDoc ) val rating by float () val votes by int () } val scoringHandle = NodeHandle < FunctionScoreNode > () val langHandle = NodeHandle < DisMaxNode > () val searchTerm = \"hello world\" val skeletonQuery = SearchQuery ( FunctionScoreNode ( scoringHandle , DisMaxNode ( langHandle , queries = listOf ( Bool . should ( QuestionDoc . title . en . match ( searchTerm ), QuestionDoc . text . en . match ( searchTerm ), ) ), ), functions = listOf ( FunctionScore . FieldValueFactor ( QuestionDoc . rating ), ), scoreMode = FunctionScore . ScoreMode . MULTIPLY , ) ) val boostByNumberOfVotes = Random . nextBoolean () var boostedQuery = if ( boostByNumberOfVotes ) { skeletonQuery . queryNode ( scoringHandle ) { node -> node . functions += listOf ( FunctionScore . Weight ( 1.1 , filter = QuestionDoc . votes . range ( gte = 10 , lt = 50 ) ), FunctionScore . Weight ( 1.5 , filter = QuestionDoc . votes . gte ( 50 ) ), ) } } else { skeletonQuery } val additionalLanguages = listOf ( \"de\" , \"ru\" ) val userLang = additionalLanguages [ Random . nextInt ( additionalLanguages . size ) ] val additionalLangFields : List < AnyField < String >> = listOfNotNull ( QuestionDoc . title . getFieldByName ( userLang ), QuestionDoc . text . getFieldByName ( userLang ), ) val langQuery = if ( additionalLangFields . isNotEmpty ()) { boostedQuery . queryNode ( langHandle ) { node -> node . queries . add ( Bool . should ( * additionalLangFields . map { it . match ( searchTerm ) }. toTypedArray () ) ) } } else { boostedQuery }","title":"Query Nodes"}]}