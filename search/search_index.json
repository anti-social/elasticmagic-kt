{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Elasticmagic \u00b6 Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk Getting started \u00b6 Setup \u00b6 Add following dependencies in your build.gradle.kts script: Todo At the moment artifacts are not yet published on maven central. Stay tuned repositories { mavenCentral () } val elasticmagicVersion = \"0.0.1\" val ktorVersion = \"1.5.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-serialization-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) } Usage \u00b6 First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.serialization.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.cio.CIO val esTransport = ElasticsearchKtorTransport ( \"http://localhost:9200\" , deserializer = JsonSerde . deserializer , engine = CIO . create {} ) val cluster = ElasticsearchCluster ( esTransport , JsonSerde ) val userIndex = cluster [ \"user\" ] Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.IndexAction import dev.evo.elasticmagic.IdentActionMeta import dev.evo.elasticmagic.list import dev.evo.elasticmagic.Refresh suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = listOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdentActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.TermsAgg import dev.evo.elasticmagic.TermsAggResult fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } suspend fun main () { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg < TermsAggResult > ( \"groups\" ) ) } You can find fully working example at Getting Started","title":"Home"},{"location":"#welcome-to-elasticmagic","text":"Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries. Warning The library is in very alpha status. API may change significantly at any time. Use it on your own risk","title":"Welcome to Elasticmagic"},{"location":"#getting-started","text":"","title":"Getting started"},{"location":"#setup","text":"Add following dependencies in your build.gradle.kts script: Todo At the moment artifacts are not yet published on maven central. Stay tuned repositories { mavenCentral () } val elasticmagicVersion = \"0.0.1\" val ktorVersion = \"1.5.2\" dependencies { // Elasticmagic core api implementation ( \"dev.evo.elasticmagic:elasticmagic: $ elasticmagicVersion \" ) // Json serialization using kotlinx.serialization implementation ( \"dev.evo.elasticmagic:elasticmagic-serde-serialization-json: $ elasticmagicVersion \" ) // Transport that uses ktor http client implementation ( \"dev.evo.elasticmagic:elasticmagic-transport-ktor: $ elasticmagicVersion \" ) implementation ( \"io.ktor:ktor-client-cio: $ ktorVersion \" ) }","title":"Setup"},{"location":"#usage","text":"First you need to describe a document (represents a mapping in terms of Elasticsearch): package samples.started import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int () val name by keyword () val groups by keyword () val about by text () } Now create ElasticsearchCluster object. It is an entry point for executing search queries: package samples.started import dev.evo.elasticmagic.ElasticsearchCluster import dev.evo.elasticmagic.serde.serialization.JsonSerde import dev.evo.elasticmagic.transport.ElasticsearchKtorTransport import io.ktor.client.engine.cio.CIO val esTransport = ElasticsearchKtorTransport ( \"http://localhost:9200\" , deserializer = JsonSerde . deserializer , engine = CIO . create {} ) val cluster = ElasticsearchCluster ( esTransport , JsonSerde ) val userIndex = cluster [ \"user\" ] Create our index if it does not exist or update the mapping otherwise: package samples.started import dev.evo.elasticmagic.Params suspend fun ensureIndexExists () { if ( ! cluster . indexExists ( userIndex . name )) { cluster . createIndex ( userIndex . name , mapping = UserDoc , settings = Params ( \"index.number_of_replicas\" to 0 , ), ) } else { cluster . updateMapping ( userIndex . name , mapping = UserDoc ) } } Describe document sources and index them: package samples.started import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.IndexAction import dev.evo.elasticmagic.IdentActionMeta import dev.evo.elasticmagic.list import dev.evo.elasticmagic.Refresh suspend fun indexDocs () { val docs = listOf ( DynDocSource { // Note that you can't write like following (it just won't compile): // it[UserDoc.id] = \"0\" // it[UserDoc.name] = 123 // it[UserDoc.groups.list()] = \"root\" it [ UserDoc . id ] = 0 it [ UserDoc . name ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . about ] = \"Super user\" }, DynDocSource { it [ UserDoc . id ] = 1 it [ UserDoc . name ] = \"daemon\" it [ UserDoc . groups . list () ] = listOf ( \"daemon\" ) it [ UserDoc . about ] = \"Daemon user\" }, DynDocSource { it [ UserDoc . id ] = 65535 it [ UserDoc . name ] = \"nobody\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Just nobody\" }, DynDocSource { it [ UserDoc . id ] = 65534 it [ UserDoc . name ] = \"noone\" it [ UserDoc . groups . list () ] = listOf ( \"nobody\" ) it [ UserDoc . about ] = \"Another nobody\" }, ) // Create index actions, make bulk request and refresh the index userIndex . bulk ( docs . map { doc -> IndexAction ( meta = IdentActionMeta ( id = doc [ UserDoc . id ] . toString ()), source = doc , ) }, refresh = Refresh . TRUE , ) } And finally we can search our data: package samples.started import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SearchQueryResult import dev.evo.elasticmagic.TermsAgg import dev.evo.elasticmagic.TermsAggResult fun printUsers ( result : SearchQueryResult < DynDocSource > ) { println ( \"Found: ${ result . totalHits } users\" ) for ( hit in result . hits ) { val user = hit . source !! println ( \" ${ user [ UserDoc . id ] } : ${ user [ UserDoc . name ] } \" ) } println () } fun printGroupsAgg ( aggResult : TermsAggResult ) { println ( \"Groups aggregation\" ) for ( bucket in aggResult . buckets ) { println ( \" ${ bucket . key } : ${ bucket . docCount } \" ) } } suspend fun main () { ensureIndexExists () indexDocs () // Find all users val sq = SearchQuery () printUsers ( sq . execute ( userIndex )) // Find nobody users sq . query ( UserDoc . about . match ( \"nobody\" )) printUsers ( sq . execute ( userIndex )) // Build an aggregation that counts users inside a group printGroupsAgg ( SearchQuery () . aggs ( \"groups\" to TermsAgg ( UserDoc . groups )) . execute ( userIndex ) . agg < TermsAggResult > ( \"groups\" ) ) } You can find fully working example at Getting Started","title":"Usage"},{"location":"docsource/","text":"Document source \u00b6 Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubDocument class RoleDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) } Dynamic \u00b6 The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = listOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = listOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten () User defined \u00b6 This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.DocSource import samples.docsource.UserDoc class RoleDocSource : DocSource () { var name by UserDoc . roles . name . required () var permissions by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { var id by UserDoc . id . required () var login by UserDoc . login . required () var groups by UserDoc . groups . required (). list (). required () var roles by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val root = UserDocSource (). apply { id = 0 login = \"root\" groups = listOf ( \"root\" , \"wheel\" ) roles = listOf ( RoleDocSource (). apply { name = \"superuser\" permissions = listOf ( \"*\" ) } ) } // Int val rootId = root . id // List<String>? val rootPermissions = root . roles ?. flatMap { it . permissions }","title":"Document source"},{"location":"docsource/#document-source","text":"Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with String or List<String> . Also all fields in a mapping are optional that requires null -checks in the code. Specifying document source we can set up proper (de)serialization of underlying data. Warning This API is a subject to change. See more info at issue Suppose we have following Document : package samples.docsource import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubDocument class RoleDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val id by int () val login by keyword () val groups by keyword () val roles by nested ( :: RoleDoc ) }","title":"Document source"},{"location":"docsource/#dynamic","text":"The most simple way to work with source documents is just to use DynDocSource : package samples.docsource.dynamic import dev.evo.elasticmagic.DynDocSource import dev.evo.elasticmagic.list import samples.docsource.UserDoc val root = DynDocSource { it [ UserDoc . id ] = 0 it [ UserDoc . login ] = \"root\" it [ UserDoc . groups . list () ] = listOf ( \"root\" , \"wheel\" ) it [ UserDoc . roles . list () ] = listOf ( DynDocSource { it [ UserDoc . roles . name ] = \"superuser\" it [ UserDoc . roles . permissions . list () ] = listOf ( \"*\" ) } ) } // Int? val rootId = root [ UserDoc . id ] // List<String?>? val rootPermissions = root [ UserDoc . roles . list () ] ?. mapNotNull { it ?. get ( UserDoc . roles . permissions . list ()) } ?. flatten ()","title":"Dynamic"},{"location":"docsource/#user-defined","text":"This is the recommended way. You can explicitly specify document source: package samples.docsource.custom import dev.evo.elasticmagic.DocSource import samples.docsource.UserDoc class RoleDocSource : DocSource () { var name by UserDoc . roles . name . required () var permissions by UserDoc . roles . permissions . required (). list (). required () } class UserDocSource : DocSource () { var id by UserDoc . id . required () var login by UserDoc . login . required () var groups by UserDoc . groups . required (). list (). required () var roles by UserDoc . roles . source ( :: RoleDocSource ). required (). list () } val root = UserDocSource (). apply { id = 0 login = \"root\" groups = listOf ( \"root\" , \"wheel\" ) roles = listOf ( RoleDocSource (). apply { name = \"superuser\" permissions = listOf ( \"*\" ) } ) } // Int val rootId = root . id // List<String>? val rootPermissions = root . roles ?. flatMap { it . permissions }","title":"User defined"},{"location":"document/","text":"Document (aka mapping) \u00b6 Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types Simple fields \u00b6 General way \u00b6 You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.BooleanType import dev.evo.elasticmagic.IntType import dev.evo.elasticmagic.KeywordType import dev.evo.elasticmagic.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id ) Using shortcuts \u00b6 There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here Sub fields \u00b6 It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubFields class AboutSubFields ( field : BoundField < String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to make sub-fields a singleton object. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubFields class AboutSubFields ( field : BoundField < String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more Object fields \u00b6 Object \u00b6 Object type just represent hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SubDocument class GroupDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API Nested \u00b6 Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.Bool import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SubDocument class RoleDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API Parent-child relationship \u00b6 Parent/child relationship allows you to define a link between documents inside an index. Join field \u00b6 package samples.document.join import dev.evo.elasticmagic.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API Merge multiple documents \u00b6 To create mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Document (aka mapping)"},{"location":"document/#document-aka-mapping","text":"Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into a single mapping. It is convenient to describe Document subclasses as singleton objects. Read more about Elasticsearch mapping types","title":"Document (aka mapping)"},{"location":"document/#simple-fields","text":"","title":"Simple fields"},{"location":"document/#general-way","text":"You can use field method to describe a field in a document: package samples.document.field import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.BooleanType import dev.evo.elasticmagic.IntType import dev.evo.elasticmagic.KeywordType import dev.evo.elasticmagic.TextType object UserDoc : Document () { // It is possible to pass field options via shortcuts like `index` // or specifying `params` argument which can include any options (see `about` field below) val id by field ( IntType , index = false , store = true ) val login by field ( KeywordType ) // By default the field name is equal to the property name // but that behaviour can be changed val isAdmin by field ( \"is_admin\" , BooleanType ) val about by field ( TextType , params = mapOf ( \"norms\" to false )) } Fields can be used when building a search query: package samples.document.field import dev.evo.elasticmagic.SearchQuery val fakeAdmins = SearchQuery ( UserDoc . about . match ( \"fake\" )) . filter ( UserDoc . isAdmin . eq ( true )) . sort ( UserDoc . id )","title":"General way"},{"location":"document/#using-shortcuts","text":"There are some nice shortcuts for popular field types. You don't need to import all those field types: package samples.document.shortcuts import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int ( index = false , store = true ) val login by keyword () val isAdmin by boolean ( \"is_admin\" ) val about by text ( norms = false ) } Full list of available shortcuts can be found here","title":"Using shortcuts"},{"location":"document/#sub-fields","text":"It is possible to define sub-fields for any simple field: package samples.document.subfields import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubFields class AboutSubFields ( field : BoundField < String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) val autocomplete by text ( analyzer = \"autocomplete\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) } Sub-fields also can be used in search queries: package samples.document.subfields import dev.evo.elasticmagic.SearchQuery val maybeNiceUsers = SearchQuery ( UserDoc . about . autocomplete . match ( \"nic\" )) . sort ( UserDoc . about . sort ) Note It is a mistake to make sub-fields a singleton object. Following example will fail at runtime. package samples.document.subfields.mistake import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SubFields class AboutSubFields ( field : BoundField < String > ) : SubFields < String > ( field ) { val sort by keyword ( normalizer = \"lowercase\" ) } object UserDoc : Document () { val about by text (). subFields ( :: AboutSubFields ) val description by text (). subFields { about } } fun main () { println ( UserDoc ) } Show an error Exception in thread \"main\" java.lang.ExceptionInInitializerError at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17) at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt) Caused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about] at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363) at samples.document.subfields.mistake.UserDoc.<clinit>(Mistake.kt:13) ... 2 more","title":"Sub fields"},{"location":"document/#object-fields","text":"","title":"Object fields"},{"location":"document/#object","text":"Object type just represent hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value: package samples.document.`object` import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SubDocument class GroupDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val id by int () val name by keyword () } object UserDoc : Document () { val groups by obj ( :: GroupDoc ) } val systemUsers = SearchQuery () . filter ( UserDoc . groups . name . eq ( \"system\" )) Note The same as with the sub-fields sub-document should not be a singleton object. Read more: Elasticsearch object type Object API","title":"Object"},{"location":"document/#nested","text":"Using nested type it you can work with sub-documents independently. In the example below we find all users that have a moderator role with both article and order permissions: package samples.document.nested import dev.evo.elasticmagic.BaseDocSource import dev.evo.elasticmagic.Bool import dev.evo.elasticmagic.BoundField import dev.evo.elasticmagic.Document import dev.evo.elasticmagic.Nested import dev.evo.elasticmagic.SearchQuery import dev.evo.elasticmagic.SubDocument class RoleDoc ( field : BoundField < BaseDocSource > ) : SubDocument ( field ) { val name by keyword () val permissions by keyword () } object UserDoc : Document () { val roles by nested ( :: RoleDoc ) } val moderators = SearchQuery () . filter ( Nested ( UserDoc . roles , Bool . must ( UserDoc . roles . name . eq ( \"moderator\" ), UserDoc . roles . permissions . eq ( \"article\" ), UserDoc . roles . permissions . eq ( \"order\" ), ) ) ) If we tried to make it with object type, we would find users that have a moderator role with article permission and view role with order permission. Read more: Elasticsearch nested type Nested API","title":"Nested"},{"location":"document/#parent-child-relationship","text":"Parent/child relationship allows you to define a link between documents inside an index.","title":"Parent-child relationship"},{"location":"document/#join-field","text":"package samples.document.join import dev.evo.elasticmagic.Document abstract class BaseQADoc : Document () { val id by int () val content by text () val join by join ( relations = mapOf ( \"question\" to listOf ( \"answer\" ))) } object QuestionDoc : BaseQADoc () { val rating by float () val title by text () } object AnswerDoc : BaseQADoc () { val accepted by boolean () } Read more: Elasticsearch join type Join API","title":"Join field"},{"location":"document/#merge-multiple-documents","text":"To create mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other. package samples.document.join import dev.evo.elasticmagic.mergeDocuments val QAMapping = mergeDocuments ( QuestionDoc , AnswerDoc ) Resulting document can be used when creating an index or updating an existing mapping.","title":"Merge multiple documents"},{"location":"querying/","text":"Querying \u00b6 To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int () val rating by float () val about by text () } Query \u00b6 You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.FunctionScore import dev.evo.elasticmagic.SearchQuery var q1 = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0 , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.Bool import dev.evo.elasticmagic.FunctionScore val q2 = q1 . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0 , ) ) ) ) Filtering \u00b6 Sorting \u00b6 Aggregations \u00b6 Query Nodes \u00b6","title":"Querying"},{"location":"querying/#querying","text":"To build a search query use a SearchQuery builder. In these samples we will utilize following document: package samples.querying import dev.evo.elasticmagic.Document object UserDoc : Document () { val id by int () val rating by float () val about by text () }","title":"Querying"},{"location":"querying/#query","text":"You can pass a query to SearchQuery directly via its constructor: package samples.querying import dev.evo.elasticmagic.FunctionScore import dev.evo.elasticmagic.SearchQuery var q1 = SearchQuery ( FunctionScore ( UserDoc . about . match ( \"fake\" ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0 , ) ) ) ) Also it is possible to replace existing query using a query method: package samples.querying import dev.evo.elasticmagic.Bool import dev.evo.elasticmagic.FunctionScore val q2 = q1 . query ( FunctionScore ( Bool . should ( UserDoc . about . match ( \"fake\" ), UserDoc . about . match ( \"real\" ), ), listOf ( FunctionScore . FieldValueFactor ( UserDoc . rating , missing = 0.0 , ) ) ) )","title":"Query"},{"location":"querying/#filtering","text":"","title":"Filtering"},{"location":"querying/#sorting","text":"","title":"Sorting"},{"location":"querying/#aggregations","text":"","title":"Aggregations"},{"location":"querying/#query-nodes","text":"","title":"Query Nodes"}]}