{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Elasticmagic","text":"<p>Elasticmagic implements advanced type awareness DSL for Kotlin to construct Elasticsearch queries.</p> <p>Warning</p> <p>The library is in very alpha status. API may change significantly at any time. Use it on your own risk</p>"},{"location":"#getting-started","title":"Getting started","text":""},{"location":"#setup","title":"Setup","text":"<p>Add following dependencies in your <code>build.gradle.kts</code> script:</p> <pre><code>repositories {\n    mavenCentral()\n}\n\nval elasticmagicVersion = \"0.3.3\"\nval ktorVersion = \"3.0.3\"\n\ndependencies {\n    // Elasticmagic core api\n    implementation(\"dev.evo.elasticmagic:elasticmagic:$elasticmagicVersion\")\n    // Json serialization using kotlinx.serialization\n    implementation(\"dev.evo.elasticmagic:elasticmagic-serde-kotlinx-json:$elasticmagicVersion\")\n    // Transport that uses ktor http client\n    implementation(\"dev.evo.elasticmagic:elasticmagic-transport-ktor:$elasticmagicVersion\")\n\n    implementation(\"io.ktor:ktor-client-cio:$ktorVersion\")\n}\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>First you need to describe a document (represents a mapping in terms of Elasticsearch):</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.doc.Document\n\nobject UserDoc : Document() {\n    val id by int()\n    val name by keyword()\n    val groups by keyword()\n    val about by text()\n}\n</code></pre> <p>Now create <code>ElasticsearchCluster</code> object. It is an entry point for executing search queries:</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.ElasticsearchCluster\nimport dev.evo.elasticmagic.serde.kotlinx.JsonSerde\nimport dev.evo.elasticmagic.transport.ElasticsearchKtorTransport\n\nconst val DEFAULT_ELASTIC_URL = \"http://localhost:9200\"\nconst val DEFAULT_ELASTIC_USER = \"elastic\"\n\nexpect val esTransport: ElasticsearchKtorTransport\nval cluster = ElasticsearchCluster(esTransport, serde = JsonSerde)\nval userIndex = cluster[\"elasticmagic-samples_user\"]\n</code></pre> <p>Any <code>ElasticsearchCluster</code> needs an <code>ElasticsearchTransport</code>. We will use the <code>ElasticsearchKtorTransport</code> that utilises Ktor http client.</p> <p>Here are examples of creating transports for the cluster.</p> <p>JVM:</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.transport.Auth\nimport dev.evo.elasticmagic.transport.ElasticsearchKtorTransport\nimport dev.evo.elasticmagic.transport.Request\nimport dev.evo.elasticmagic.transport.Response\nimport dev.evo.elasticmagic.transport.PlainRequest\nimport dev.evo.elasticmagic.transport.PlainResponse\nimport dev.evo.elasticmagic.transport.Tracker\n\nimport io.ktor.client.engine.cio.CIO\n\nimport java.security.cert.X509Certificate\nimport javax.net.ssl.X509TrustManager\n\nimport kotlin.time.Duration\nimport kotlin.getOrThrow\n\nactual val esTransport = ElasticsearchKtorTransport(\n    System.getenv(\"ELASTIC_URL\") ?: DEFAULT_ELASTIC_URL,\n    engine = CIO.create {\n        https {\n            trustManager = object: X509TrustManager {\n                override fun checkClientTrusted(\n                    chain: Array&lt;out X509Certificate&gt;?, authType: String?\n                ) {}\n\n                override fun checkServerTrusted(\n                    chain: Array&lt;out X509Certificate&gt;?, authType: String?\n                ) {}\n\n                override fun getAcceptedIssuers(): Array&lt;X509Certificate&gt;? = null\n            }\n        }\n    }\n) {\n    val elasticUser = System.getenv(\"ELASTIC_USER\") ?: DEFAULT_ELASTIC_USER\n    val elasticPassword = System.getenv(\"ELASTIC_PASSWORD\")\n    if (!elasticPassword.isNullOrEmpty()) {\n        auth = Auth.Basic(elasticUser, elasticPassword)\n    }\n\n    if (System.getenv(\"ELASTICMAGIC_DEBUG\") != null) {\n        trackers = listOf {\n            object : Tracker {\n                override fun requiresTextContent(request: Request&lt;*, *, *&gt;) = true\n\n                override suspend fun onRequest(request: PlainRequest) {\n                    println(\"&gt;&gt;&gt;\")\n                    println(\"${request.method} ${request.path.ifEmpty { \"/\" }}\")\n                    println(request.textContent)\n                }\n\n                override suspend fun onResponse(responseResult: Result&lt;PlainResponse&gt;, duration: Duration) {\n                    responseResult\n                        .onSuccess { response -&gt;\n                            println(\"&lt;&lt;&lt; ${response.statusCode}: ${duration}\")\n                            response.headers.forEach { header -&gt;\n                                println(\"&lt; ${header.key}: ${header.value}\")\n                            }\n                            println(response.contentType)\n                            println(response.content)\n                        }\n                        .onFailure { exception -&gt;\n                            println(\"!!! $exception\")\n                        }\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Native:</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.serde.kotlinx.JsonSerde\nimport dev.evo.elasticmagic.transport.Auth\nimport dev.evo.elasticmagic.transport.ElasticsearchKtorTransport\n\nimport io.ktor.client.engine.curl.Curl\n\nimport kotlinx.cinterop.toKString\n\nimport platform.posix.getenv\n\n@OptIn(kotlinx.cinterop.ExperimentalForeignApi::class)\nactual val esTransport = ElasticsearchKtorTransport(\n    getenv(\"ELASTIC_URL\")?.toKString() ?: DEFAULT_ELASTIC_URL,\n    engine = Curl.create {\n        sslVerify = false\n    }\n) {\n    val elasticUser = getenv(\"ELASTIC_USER\")?.toKString() ?: DEFAULT_ELASTIC_USER\n    val elasticPassword = getenv(\"ELASTIC_PASSWORD\")?.toKString()\n    if (!elasticPassword.isNullOrEmpty()) {\n        auth = Auth.Basic(elasticUser, elasticPassword)\n    }\n}\n</code></pre> <p>Create our index if it does not exist or update the mapping otherwise:</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.Params\n\nsuspend fun ensureIndexExists() {\n    if (!cluster.indexExists(userIndex.name)) {\n        cluster.createIndex(\n            userIndex.name,\n            mapping = UserDoc,\n            settings = Params(\n                \"index.number_of_replicas\" to 0,\n            ),\n        )\n    } else {\n        cluster.updateMapping(userIndex.name, mapping = UserDoc)\n    }\n}\n</code></pre> <p>Describe document sources and index them: </p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.Refresh\nimport dev.evo.elasticmagic.doc.DynDocSource\nimport dev.evo.elasticmagic.bulk.IndexAction\nimport dev.evo.elasticmagic.bulk.IdActionMeta\nimport dev.evo.elasticmagic.doc.list\n\nsuspend fun indexDocs() {\n    val docs = listOf(\n        DynDocSource {\n            // Note that you can't write like following (it just won't compile):\n            // it[UserDoc.id] = \"0\"\n            // it[UserDoc.name] = 123\n            // it[UserDoc.groups.list()] = \"root\"\n            it[UserDoc.id] = 0\n            it[UserDoc.name] = \"root\"\n            it[UserDoc.groups.list()] = mutableListOf(\"root\", \"wheel\")\n            it[UserDoc.about] = \"Super user\"\n        },\n        DynDocSource {\n            it[UserDoc.id] = 1\n            it[UserDoc.name] = \"daemon\"\n            it[UserDoc.groups.list()] = mutableListOf(\"daemon\")\n            it[UserDoc.about] = \"Daemon user\"\n        },\n        DynDocSource {\n            it[UserDoc.id] = 65535\n            it[UserDoc.name] = \"nobody\"\n            it[UserDoc.groups.list()] = mutableListOf(\"nobody\")\n            it[UserDoc.about] = \"Just nobody\"\n        },\n        DynDocSource {\n            it[UserDoc.id] = 65534\n            it[UserDoc.name] = \"noone\"\n            it[UserDoc.groups.list()] = mutableListOf(\"nobody\")\n            it[UserDoc.about] = \"Another nobody\"\n        },\n    )\n    // Create index actions, make bulk request and refresh the index\n    userIndex.bulk(\n        docs.map { doc -&gt;\n            IndexAction(\n                meta = IdActionMeta(id = doc[UserDoc.id].toString()),\n                source = doc,\n            )\n        },\n        refresh = Refresh.TRUE,\n    )\n}\n</code></pre> <p>And finally we can search our data:</p> <pre><code>package samples.started\n\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.SearchQueryResult\nimport dev.evo.elasticmagic.aggs.TermsAgg\nimport dev.evo.elasticmagic.aggs.TermsAggResult\nimport dev.evo.elasticmagic.doc.DynDocSource\nimport dev.evo.elasticmagic.query.match\n\nimport kotlinx.coroutines.runBlocking\n\nfun printUsers(result: SearchQueryResult&lt;DynDocSource&gt;) {\n    println(\"Found: ${result.totalHits} users\")\n    for (hit in result.hits) {\n        val user = hit.source!!\n        println(\"  ${user[UserDoc.id]}: ${user[UserDoc.name]}\")\n    }\n    println()\n}\n\nfun printGroupsAgg(aggResult: TermsAggResult&lt;String&gt;) {\n    println(\"Groups aggregation\")\n    for (bucket in aggResult.buckets) {\n        println(\"  ${bucket.key}: ${bucket.docCount}\")\n    }\n}\n\nfun main() = runBlocking {\n    ensureIndexExists()\n    indexDocs()\n\n    // Find all users\n    val sq = SearchQuery()\n    printUsers(sq.search(userIndex))\n\n    // Find nobody users\n    sq.query(UserDoc.about.match(\"nobody\"))\n    printUsers(sq.search(userIndex))\n\n    // Build an aggregation that counts users inside a group\n    printGroupsAgg(\n        SearchQuery()\n            .aggs(\"groups\" to TermsAgg(UserDoc.groups))\n            .search(userIndex)\n            .agg(\"groups\")\n    )\n}\n</code></pre>"},{"location":"#run-the-sample","title":"Run the sample","text":"<p>You can find fully working example inside samples</p> <p>And run it with as JVM application (of cause you need Elasticsearch available at <code>localhost:9200</code>):</p> <pre><code>./gradlew :samples:run\n</code></pre> <p>or native:</p> <pre><code>./gradlew :samples:runDebugExecutableNative\n</code></pre>"},{"location":"docsource/","title":"Document source","text":"<p>Document source represents an Elasticsearch document in Kotlin. Document source is responsible for data serialization/deserialization. For example, almost all Elasticsearch data types can be multi-valued and a mapping doesn't reflect that fact. But in our programs we want to operate with concrete types, as we work differently with <code>String</code> or <code>List&lt;String&gt;</code>. Also all fields in a mapping are optional that requires <code>null</code>-checks in the code. Specifying document source we can set up proper (de)serialization of underlying data.</p> <p>Warning</p> <p>This API is a subject to change.  See more info at issue</p> <p>Suppose we have following <code>Document</code>:</p> <pre><code>package samples.docsource\n\nimport dev.evo.elasticmagic.doc.BaseDocSource\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.SubDocument\n\nclass RoleDoc(field: BoundField&lt;BaseDocSource, Nothing&gt;) : SubDocument(field) {\n    val name by keyword()\n    val permissions by keyword()\n}\n\nobject UserDoc : Document() {\n    val id by int()\n    val login by keyword()\n    val groups by keyword()\n    val roles by nested(::RoleDoc)\n}\n</code></pre>"},{"location":"docsource/#dynamic","title":"Dynamic","text":"<p>The most simple way to work with source documents is just to use <code>DynDocSource</code>:</p> <pre><code>package samples.docsource.dynamic\n\nimport dev.evo.elasticmagic.doc.DynDocSource\nimport dev.evo.elasticmagic.doc.list\n\nimport samples.docsource.UserDoc\n\nval root = DynDocSource {\n    it[UserDoc.id] = 0\n    it[UserDoc.login] = \"root\"\n    it[UserDoc.groups.list()] = mutableListOf(\"root\", \"wheel\")\n    it[UserDoc.roles.list()] = mutableListOf(\n        DynDocSource {\n            it[UserDoc.roles.name] = \"superuser\"\n            it[UserDoc.roles.permissions.list()] = mutableListOf(\"*\")\n        }\n    )\n}\n\n// Int?\nval rootId = root[UserDoc.id]\n\n// List&lt;String?&gt;?\nval rootPermissions = root[UserDoc.roles.list()]\n    ?.mapNotNull {\n        it?.get(UserDoc.roles.permissions.list())\n    }\n    ?.flatten()\n</code></pre>"},{"location":"docsource/#user-defined","title":"User defined","text":"<p>This is the recommended way. You can explicitly specify document source:</p> <pre><code>package samples.docsource.custom\n\nimport dev.evo.elasticmagic.doc.DocSource\n\nimport samples.docsource.UserDoc\n\n// Explicit types are specified for clarity. You can totally omit them\n\nclass RoleDocSource : DocSource() {\n    var name: String by UserDoc.roles.name.required()\n    var permissions: MutableList&lt;String&gt; by UserDoc.roles.permissions.required().list().required()\n}\n\nclass UserDocSource : DocSource() {\n    // id and login fields must be present\n    var id: Int by UserDoc.id.required()\n    var login: String by UserDoc.login.required()\n\n    // If groups field is missing or null default value will be used\n    var groups: MutableList&lt;String&gt; by UserDoc.groups.required().list().default { mutableListOf() }\n\n    // Optional list of a required RoleDocSource instances\n    var roles: MutableList&lt;RoleDocSource&gt;? by UserDoc.roles.source(::RoleDocSource).required().list()\n}\n\nval nobody = UserDocSource().apply {\n    id = 65535\n    login = \"nobody\"\n}\n\nval nobodyHasGroups = nobody.groups.isEmpty()\n\nval root = UserDocSource().apply {\n    id = 0\n    login = \"root\"\n    groups = mutableListOf(\"root\", \"wheel\")\n    roles = mutableListOf(\n        RoleDocSource().apply {\n            name = \"superuser\"\n            permissions = mutableListOf(\"*\")\n        }\n    )\n}\n\nval rootId: Int = root.id\n\nval rootPermissions: List&lt;String&gt;? = root.roles\n    ?.flatMap {\n        it.permissions\n    }\n</code></pre>"},{"location":"document/","title":"Document (aka mapping)","text":"<p>Roughly speaking Document represents Elasticsearch's mapping. However, it is possible to merge multiple documents into  a single mapping.</p> <p>It is convenient to describe <code>Document</code> subclasses as singleton objects.</p> <p>Read more about  Elasticsearch mapping types</p>"},{"location":"document/#simple-fields","title":"Simple fields","text":""},{"location":"document/#general-way","title":"General way","text":"<p>You can use field method to describe a field in a document:</p> <pre><code>package samples.document.field\n\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.types.BooleanType\nimport dev.evo.elasticmagic.types.IntType\nimport dev.evo.elasticmagic.types.KeywordType\nimport dev.evo.elasticmagic.types.TextType\n\nobject UserDoc : Document() {\n    // It is possible to pass field options via shortcuts like `index`\n    // or specifying `params` argument which can include any options (see `about` field below)\n    val id by field(IntType, index = false, store = true)\n\n    val login by field(KeywordType)\n\n    // By default the field name is equal to the property name\n    // but that behaviour can be changed\n    val isAdmin by field(\"is_admin\", BooleanType)\n\n    val about by field(TextType, params = mapOf(\"norms\" to false))\n}\n</code></pre> <p>Fields can be used when building a search query:</p> <pre><code>package samples.document.field\n\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.query.match\n\nval fakeAdmins = SearchQuery(UserDoc.about.match(\"fake\"))\n    .filter(UserDoc.isAdmin.eq(true))\n    .sort(UserDoc.id)\n</code></pre>"},{"location":"document/#using-shortcuts","title":"Using shortcuts","text":"<p>There are some nice shortcuts for popular field types.  You don't need to import all those field types:</p> <pre><code>package samples.document.shortcuts\n\nimport dev.evo.elasticmagic.doc.Document\n\nobject UserDoc : Document() {\n    val id by int(index = false, store = true)\n    val login by keyword()\n    val isAdmin by boolean(\"is_admin\")\n    val about by text(norms = false)\n}\n</code></pre> <p>Full list of available shortcuts can be found here</p>"},{"location":"document/#enums","title":"Enums","text":"<p>It is possible to map field values to kotlin enums. Use enum extension function for that:</p> <pre><code>package samples.document.enums\n\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.enum\n\nenum class UserStatus {\n    ACTIVE, LOCKED, NO_PASSWORD\n}\n\nobject UserDoc : Document() {\n    val status by keyword().enum&lt;UserStatus&gt;()\n}\n</code></pre> <p>Now you are able to use enum variants in your search queries:</p> <pre><code>package samples.document.enums\n\nimport dev.evo.elasticmagic.SearchQuery\n\nval q = SearchQuery()\n    .filter(\n        UserDoc.status.eq(UserStatus.ACTIVE)\n    )\n</code></pre>"},{"location":"document/#sub-fields","title":"Sub fields","text":"<p>It is possible to define sub-fields for any simple field:</p> <pre><code>package samples.document.subfields\n\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.SubFields\n\nclass AboutSubFields(field: BoundField&lt;String, String&gt;) : SubFields&lt;String&gt;(field) {\n    val sort by keyword(normalizer = \"lowercase\")\n    val autocomplete by text(analyzer = \"autocomplete\")\n}\n\nobject UserDoc : Document() {\n    val about by text().subFields(::AboutSubFields)\n}\n</code></pre> <p>Sub-fields also can be used in search queries:</p> <pre><code>package samples.document.subfields\n\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.query.match\n\nval maybeNiceUsers = SearchQuery(UserDoc.about.autocomplete.match(\"nic\"))\n    .sort(UserDoc.about.sort)\n</code></pre> <p>Note</p> <p>It is a mistake to use sub-fields twice. Following example will fail at runtime.</p> <pre><code>package samples.document.subfields.mistake\n\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.SubFields\n\nclass AboutSubFields(field: BoundField&lt;String, String&gt;) : SubFields&lt;String&gt;(field) {\n    val sort by keyword(normalizer = \"lowercase\")\n}\n\nobject UserDoc : Document() {\n    val about by text().subFields(::AboutSubFields)\n    val description by text().subFields { about }\n}\n\nfun main() {\n    println(UserDoc)\n}\n</code></pre> Show an error <pre><code>Exception in thread \"main\" java.lang.ExceptionInInitializerError\n        at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt:17)\n        at samples.document.subfields.mistake.MistakeKt.main(Mistake.kt)\nCaused by: java.lang.IllegalStateException: Field [description] has already been initialized as [about]\n        at dev.evo.elasticmagic.SubFields$UnboundSubFields.provideDelegate(Document.kt:363)\n        at samples.document.subfields.mistake.UserDoc.&lt;clinit&gt;(Mistake.kt:13)\n        ... 2 more\n</code></pre>"},{"location":"document/#object-fields","title":"Object fields","text":""},{"location":"document/#object","title":"Object","text":"<p>Object type just represents a hierarchical structure. It is similar to sub-fields but every field in a sub-document can have its own source value:</p> <pre><code>package samples.document.`object`\n\nimport dev.evo.elasticmagic.doc.BaseDocSource\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.doc.SubDocument\n\nclass GroupDoc(field: BoundField&lt;BaseDocSource, Nothing&gt;) : SubDocument(field) {\n    val id by int()\n    val name by keyword()\n}\n\nobject UserDoc : Document() {\n    val groups by obj(::GroupDoc)\n}\n\nval systemUsers = SearchQuery()\n    .filter(UserDoc.groups.name.eq(\"system\"))\n</code></pre> <p>Note</p> <p>The same as with the sub-fields sub-document should not be a singleton object. </p> <p>Read more:</p> <ul> <li>Elasticsearch object type</li> <li>Object API</li> </ul>"},{"location":"document/#nested","title":"Nested","text":"<p>Using nested type it you can work with sub-documents independently.  In the example below we find all users that have a <code>moderator</code> role with both  <code>article</code> and <code>order</code> permissions:</p> <pre><code>package samples.document.nested\n\nimport dev.evo.elasticmagic.doc.BaseDocSource\nimport dev.evo.elasticmagic.query.Bool\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.query.Nested\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.doc.SubDocument\n\nclass RoleDoc(field: BoundField&lt;BaseDocSource, Nothing&gt;) : SubDocument(field) {\n    val name by keyword()\n    val permissions by keyword()\n}\n\nobject UserDoc : Document() {\n    val roles by nested(::RoleDoc)\n}\n\nval moderators = SearchQuery()\n    .filter(\n        Nested(\n            UserDoc.roles,\n            Bool.must(\n                UserDoc.roles.name.eq(\"moderator\"),\n                UserDoc.roles.permissions.eq(\"article\"),\n                UserDoc.roles.permissions.eq(\"order\"),\n            )\n        )\n    )\n</code></pre> <p>If we tried to make it with <code>object</code> type, we would find users that have  a <code>moderator</code> role with <code>article</code> permission and <code>view</code> role with <code>order</code> permission.</p> <p>Read more:</p> <ul> <li>Elasticsearch nested type</li> <li>Nested API</li> </ul>"},{"location":"document/#parent-child-relationship","title":"Parent-child relationship","text":"<p>Parent/child relationship allows you to define a link between documents inside an index.</p>"},{"location":"document/#join-field","title":"Join field","text":"<pre><code>package samples.document.join\n\nimport dev.evo.elasticmagic.doc.Document\n\nabstract class BaseQADoc : Document() {\n    val id by int()\n    val content by text()\n    val join by join(relations = mapOf(\"question\" to listOf(\"answer\")))\n}\n\nobject QuestionDoc : BaseQADoc() {\n    val rating by float()\n    val title by text()\n}\n\nobject AnswerDoc : BaseQADoc() {\n    val accepted by boolean()\n}\n</code></pre> <p>Read more:</p> <ul> <li>Elasticsearch join type</li> <li>Join API</li> </ul>"},{"location":"document/#meta-fields","title":"Meta fields","text":"<p>Elasticsearch mapping has metadata fields. Some of those fields can be customized. In following example we make a value for <code>_routing</code> field required and keep only <code>name</code> field in document source:</p> <pre><code>package samples.document.meta\n\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.MetaFields\n\nobject ProductDoc : Document() {\n    val name by text()\n    val companyId by int()\n\n    override val meta = object : MetaFields() {\n        override val routing by RoutingField(required = true)\n        override val source by SourceField(includes = listOf(\"name\"))\n    }\n}\n</code></pre> <p>Now you must provide the required routing value when indexing documents otherwise Elasticsearch will throw <code>routing_missing_exceptions</code>.</p>"},{"location":"document/#merge-multiple-documents","title":"Merge multiple documents","text":"<p>To create a mapping for multiple documents you can use mergeDocuments function. Documents that are merged should not contradict each other.</p> <pre><code>package samples.document.join\n\nimport dev.evo.elasticmagic.doc.mergeDocuments\n\nval QAMapping = mergeDocuments(QuestionDoc, AnswerDoc)\n</code></pre> <p>Resulting document can be used when creating an index or updating an existing mapping. </p>"},{"location":"query-filters/","title":"Query Filters","text":"<p>Query filters allow you to describe search query modifications declaratively. It is possible to filter, sort, paginate and build facets using query filters.</p> <p>Let's describe our new document:</p> <pre><code>package samples.qf\n\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.enum\n\nenum class BikeKind {\n    BMX, MTB, CITY, ROAD, CYCLOCROSS, GRAVEL, EBIKE;\n}\n\nobject BikeDoc : Document() {\n    val price by float()\n    val manufacturer by keyword()\n    val model by text()\n    val kind by keyword().enum(BikeKind::name)\n    val weight by float()\n}\n</code></pre> <p>Now we can describe query filters for the <code>BikeDoc</code>:</p> <pre><code>package samples.qf\n\nimport dev.evo.elasticmagic.qf.FacetFilter\nimport dev.evo.elasticmagic.qf.FacetRangeFilter\nimport dev.evo.elasticmagic.qf.PageFilter\nimport dev.evo.elasticmagic.qf.QueryFilters\nimport dev.evo.elasticmagic.qf.SortFilter\nimport dev.evo.elasticmagic.qf.SortFilterValue\n\nobject BikeQueryFilters : QueryFilters() {\n    val price by FacetRangeFilter(BikeDoc.price)\n    val manufacturer by FacetFilter(BikeDoc.manufacturer)\n    val kind by FacetFilter(BikeDoc.kind)\n    val weight by FacetRangeFilter(BikeDoc.weight)\n\n    val sort by SortFilter(\n        SortFilterValue(\"price\", listOf(BikeDoc.price)),\n        SortFilterValue(\"-price\", listOf(BikeDoc.price.desc())),\n        SortFilterValue(\"weight\", listOf(BikeDoc.weight)),\n    )\n\n    val page by PageFilter()\n}\n</code></pre> <p>To apply it to a search query you need query filter parameters. They are just a mapping where keys are a pair of filter name and an operation, and values are a list of strings. For example, it could be transformed from http query parameters.</p> <pre><code>package samples.qf\n\nimport dev.evo.elasticmagic.SearchQuery\n\n// You can imagine it could be converted from following http query parameters:\n// manufacturer=Giant&amp;manufacturer=Cannondale&amp;\n// kind=CITY&amp;kind=CYCLOCROSS&amp;kind=GRAVEL&amp;\n// price__lte=2000&amp;\n// sort=weight&amp;\n// page=2&amp;\nval qfParams = mapOf(\n    listOf(\"manufacturer\") to listOf(\"Giant\", \"Cannondale\"),\n    listOf(\"kind\") to listOf(\"CITY\", \"CYCLOCROSS\", \"GRAVEL\"),\n    listOf(\"price\", \"lte\") to listOf(\"2000\"),\n    listOf(\"sort\") to listOf(\"weight\"),\n    listOf(\"page\") to listOf(\"2\"),\n)\n\nval searchQuery = SearchQuery()\n\nval appliedFilters = BikeQueryFilters.apply(searchQuery, qfParams)\n\n// Now searchQuery is filtered, sorted, paginated and corresponding aggregations\n// to calculate facets are added\n</code></pre> <p>After executing query we are able to process its results:</p> <pre><code>package samples.qf\n\nimport dev.evo.elasticmagic.doc.DynDocSource\nimport samples.started.cluster\n\nsuspend fun process() {\n    val filtersResult = appliedFilters.processResult(\n        searchQuery.search(cluster[\"elasticmagic-samples_bike\"])\n    )\n\n    val manufacturerFacet = filtersResult[BikeQueryFilters.manufacturer]\n    println(\"Manufacturers:\")\n    for (manufacturer in manufacturerFacet) {\n        val selectedMark = if (manufacturer.selected) \"x\" else \" \"\n        println(\"  [$selectedMark] ${manufacturer.value} (${manufacturer.count})\")\n    }\n    println()\n\n    val kindFacet = filtersResult[BikeQueryFilters.kind]\n    println(\"Kinds:\")\n    for (kind in kindFacet) {\n        val selectedMark = if (kind.selected) \"x\" else \" \"\n        println(\"  [$selectedMark] ${kind.value} (${kind.count})\")\n    }\n    println()\n\n    val page = filtersResult[BikeQueryFilters.page]\n    println(\"Results:\")\n    for (hit in page) {\n        val source = requireNotNull(hit.source) as DynDocSource\n\n        println(\"  ${source[BikeDoc.manufacturer]} ${source[BikeDoc.model]} - ${source[BikeDoc.price]}\")\n    }\n    println()\n    println(\"Current page: ${page.page}\")\n    println(\"Total pages: ${page.totalPages}\")\n    println()\n}\n</code></pre>"},{"location":"query-filters/#run-a-full-fledged-query-filters-sample","title":"Run a full-fledged query filters sample","text":"<p>JVM version:</p> <pre><code>./gradlew :samples:runBikeshop -q --console=plain\n</code></pre> <p>Native version:</p> <pre><code>./gradlew :samples:linkBikeshopDebugExecutableNative\n./samples/build/bin/native/bikeshopDebugExecutable/bikeshop.kexe\n</code></pre> <p>Both versions support following environment variables:</p> <ul> <li><code>ELASTIC_URL</code> - URL to your Elasticsearch cluster. Default is <code>http://localhost:9200</code>.   If you want to use TLS change it to <code>https://localhost:9200</code>. Elasticsearch <code>8.x</code> and   Opensearch <code>2.x</code> turn on TLS by default.</li> <li><code>ELASTIC_USER</code> - user for a basic authentication. Default is <code>elastic</code>.   Change it to <code>admin</code> if you use Opensearch.</li> <li><code>ELASTIC_PASSWORD</code> - if this variable is set, basic authentication will be used.   Set it to a real password of your cluster or leave empty if your cluster doesn't require   authentication. Password for default configuration of Elasticsearch <code>8.x</code> can be found in logs.   Default password for Opensearch <code>2.x</code> is <code>admin</code>.</li> </ul>"},{"location":"querying/","title":"Querying","text":"<p>To build a search query use a SearchQuery builder.</p> <p>In these samples we will utilize following document:</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.doc.Document\n\nobject UserDoc : Document() {\n    val id by int()\n    val isActive by boolean(\"is_active\")\n    val groups by keyword()\n    val rating by float()\n    val about by text()\n}\n</code></pre>"},{"location":"querying/#query","title":"Query","text":"<p>You can pass a query to <code>SearchQuery</code> directly via its constructor:</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.query.FunctionScore\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.query.match\n\nvar q = SearchQuery(\n    FunctionScore(\n        UserDoc.about.match(\"fake\"),\n        listOf(\n            FunctionScore.FieldValueFactor(\n                UserDoc.rating,\n                missing = 0.0F,\n            )\n        )\n    )\n)\n</code></pre> <p>Also it is possible to replace existing query using a <code>query</code> method: </p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.query.Bool\nimport dev.evo.elasticmagic.query.FunctionScore\nimport dev.evo.elasticmagic.query.match\n\nval q2 = q.query(\n    FunctionScore(\n        Bool.should(\n            UserDoc.about.match(\"fake\"),\n            UserDoc.about.match(\"real\"),\n        ),\n        listOf(\n            FunctionScore.FieldValueFactor(\n                UserDoc.rating,\n                missing = 0.0F,\n            )\n        )\n    )\n)\n</code></pre> <p>See full list of available query expressions.</p>"},{"location":"querying/#cloning","title":"Cloning","text":"<p>In the last example <code>q</code> and <code>q2</code> variables point to the same object. For efficiency all <code>SearchQuery</code> methods modify current instance and return it for chaining method calls.</p> <p>If you want to get independent query instance you should clone it explicitly:</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.query.match\n\nval clonedQuery = q.clone()\n    .query(UserDoc.about.match(\"fake\"))\n</code></pre> <p>Now you can modify <code>clonedQuery</code> without touching its ancestor <code>q</code>.</p>"},{"location":"querying/#filtering","title":"Filtering","text":"<p>Using filter method you can filter your query. All filters passed to the <code>filter</code> method will be combined using <code>AND</code> operation.</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.query.Bool\nimport dev.evo.elasticmagic.query.match\n\n// Select only active users that id is not equal 0\nval activeUsersQuery = q\n    .filter(UserDoc.isActive.eq(true))\n    .filter(UserDoc.id.ne(0))\n\n// The same as above\nval activeUsersQuery2 = q\n    .filter(\n        UserDoc.isActive.eq(true),\n        UserDoc.id.ne(0)\n    )\n\n// If you need one condition OR another use Bool.should expression.\n// In the following example we select non-active users OR \"fake\" users\nval activeUsersQuery3 = q\n    .filter(\n        Bool.should(\n            UserDoc.isActive.ne(true),\n            UserDoc.about.match(\"fake\")\n        )\n    )\n</code></pre> <p>See Query Filter Context</p>"},{"location":"querying/#sorting","title":"Sorting","text":"<p>sort method has 2 flavors:</p> <ul> <li>a shortcut that accepts document fields</li> <li>and full-featured version accepting Sort   expressions</li> </ul> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.query.Sort\n\n// Sort by user id with ascending order\nval sortedByIdQuery = q.sort(UserDoc.id)\n\n// Sort by user id descending\nval sortedByIdDescQuery = q.sort(UserDoc.id.desc())\n\n// Sort by several criteria\nval multipleSortedQuery = q.sort(UserDoc.isActive.desc(), UserDoc.id.asc())\n\n// Use Sort explicitly to customize sort behaviour\nval sortedByRatingQuery = q.sort(Sort(UserDoc.rating, missing = Sort.Missing.First))\n</code></pre> <p>See:</p> <ul> <li>Sort Search Results</li> </ul>"},{"location":"querying/#aggregations","title":"Aggregations","text":"<p>Use aggs method to define aggregations:</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.aggs.AvgAgg\nimport dev.evo.elasticmagic.aggs.HistogramAgg\nimport dev.evo.elasticmagic.aggs.TermsAgg\n\n// Build aggregations by groups and calculate average rating as well as\n// build histogram by rating for every group\nval ratingHistogramQuery = q.aggs(\n    \"groups\" to TermsAgg(\n        UserDoc.groups,\n        aggs = mapOf(\n            \"avg_rating\" to AvgAgg(UserDoc.rating),\n            \"rating_histogram\" to HistogramAgg(\n                UserDoc.rating, interval = 10.0F\n            ),\n        )\n    )\n)\n</code></pre> <p>See Search Aggregations</p>"},{"location":"querying/#query-nodes","title":"Query Nodes","text":"<p>Sometimes you don't know final form of your query when creating it. For such a usecase it is possible to replace parts of the query after creation using special query expressions and queryNode method:</p> <pre><code>package samples.querying\n\nimport dev.evo.elasticmagic.SearchQuery\nimport dev.evo.elasticmagic.doc.BaseDocSource\nimport dev.evo.elasticmagic.doc.BoundField\nimport dev.evo.elasticmagic.doc.Document\nimport dev.evo.elasticmagic.doc.MappingField\nimport dev.evo.elasticmagic.doc.SubDocument\nimport dev.evo.elasticmagic.query.Bool\nimport dev.evo.elasticmagic.query.DisMax\nimport dev.evo.elasticmagic.query.FunctionScore\nimport dev.evo.elasticmagic.query.match\nimport dev.evo.elasticmagic.query.NodeHandle\nimport dev.evo.elasticmagic.query.QueryExpressionNode\n\nimport kotlin.random.Random\n\nclass TranslationDoc(field: BoundField&lt;BaseDocSource, Nothing&gt;) : SubDocument(field) {\n    val en by text()\n    val de by text()\n    val ru by text()\n}\n\nobject QuestionDoc : Document() {\n    val title by obj(::TranslationDoc)\n    val text by obj(::TranslationDoc)\n    val rating by float()\n    val votes by int()\n}\n\nval scoringHandle = NodeHandle&lt;FunctionScore&gt;()\nval langHandle = NodeHandle&lt;DisMax&gt;()\n\nval searchTerm = \"hello world\"\nval skeletonQuery = SearchQuery(\n    QueryExpressionNode(\n        scoringHandle,\n        FunctionScore(\n            QueryExpressionNode(\n                langHandle,\n                DisMax(\n                    queries = listOf(\n                        Bool.should(\n                            QuestionDoc.title.en.match(searchTerm),\n                            QuestionDoc.text.en.match(searchTerm),\n                        )\n                    ),\n                )\n            ),\n            functions = listOf(\n                FunctionScore.FieldValueFactor(QuestionDoc.rating),\n            ),\n            scoreMode = FunctionScore.ScoreMode.MULTIPLY,\n        )\n    )\n)\n\nval boostByNumberOfVotes = Random.nextBoolean()\nvar boostedQuery = if (boostByNumberOfVotes) {\n    skeletonQuery.queryNode(scoringHandle) { node -&gt;\n        node.copy(\n            functions = node.functions + listOf(\n                FunctionScore.Weight(\n                    1.1F,\n                    filter = QuestionDoc.votes.range(gte = 10, lt = 50)\n                ),\n                FunctionScore.Weight(\n                    1.5F,\n                    filter = QuestionDoc.votes.gte(50)\n                ),\n            )\n        )\n    }\n} else {\n    skeletonQuery\n}\n\nval additionalLanguages = listOf(\"de\", \"ru\")\nval userLang = additionalLanguages[Random.nextInt(additionalLanguages.size)]\nval additionalLangFields: List&lt;MappingField&lt;String&gt;&gt; = listOfNotNull(\n    QuestionDoc.title.getFieldByName(userLang),\n    QuestionDoc.text.getFieldByName(userLang),\n)\nval langQuery = if (additionalLangFields.isNotEmpty()) {\n    boostedQuery.queryNode(langHandle) { node -&gt;\n        node.copy(\n            queries = node.queries + listOf(\n                Bool.should(\n                    *additionalLangFields.map { it.match(searchTerm) }.toTypedArray()\n                )\n            )\n        )\n    }\n} else {\n    boostedQuery\n}\n</code></pre>"}]}